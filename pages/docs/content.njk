<h1 id="v-documentation"><a class="markdownIt-Anchor" href="#v-documentation">#</a> V Documentation</h1>
<p>(See https://modules.vlang.io/ for documentation of V's standard library)</p>
<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction">#</a> Introduction</h2>
<p>V is a statically typed compiled programming language designed for building maintainable software.</p>
<p>It's similar to Go and its design has also been influenced by Oberon, Rust, Swift,
Kotlin, and Python.</p>
<p>V is a very simple language. Going through this documentation will take you about an hour,
and by the end of it you will have pretty much learned the entire language.</p>
<p>The language promotes writing simple and clear code with minimal abstraction.</p>
<p>Despite being simple, V gives the developer a lot of power.
Anything you can do in other languages, you can do in V.</p>
<h2 id="installing-v-from-source"><a class="markdownIt-Anchor" href="#installing-v-from-source">#</a> Installing V from source</h2>
<p>The best way to get the latest and greatest V, is to install it from source.
It is easy, and it takes only a few seconds:</p>
{% set code = "git clone https://github.com/vlang/v\ncd v\nmake\n# HINT: Using Windows?: run make.bat in the cmd.exe shell" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>For more details, see the
<a href="https://github.com/vlang/v/blob/master/README.md#installing-v-from-source">Installing V</a>
section in the README.md.</p>
<h2 id="upgrading-v-to-latest-version"><a class="markdownIt-Anchor" href="#upgrading-v-to-latest-version">#</a> Upgrading V to latest version</h2>
<p>If V is already installed on a machine, it can be upgraded to its latest version
by using the V's built-in self-updater.
To do so, run the command <code>v up</code>.</p>
<h2 id="getting-started"><a class="markdownIt-Anchor" href="#getting-started">#</a> Getting started</h2>
<p>You can let V automatically set up the bare-bones structure of a project for you
by using any of the following commands in a terminal:</p>
<ul>
<li><code>v init</code> ‚Üí adds necessary files to the current folder to make it a V project</li>
<li><code>v new abc</code> ‚Üí creates a new project in the new folder <code>abc</code>, by default a &quot;hello world&quot; project.</li>
<li><code>v new abcd web</code> ‚Üí creates a new project in the new folder <code>abcd</code>, using the vweb template.</li>
</ul>
<h2 id="table-of-contents"><a class="markdownIt-Anchor" href="#table-of-contents">#</a> Table of Contents</h2>
<p>&lt;table&gt;
&lt;tr&gt;&lt;td width=33% valign=top&gt;</p>
<ul>
<li><a href="#hello-world">Hello world</a></li>
<li><a href="#running-a-project-folder-with-several-files">Running a project folder</a></li>
<li><a href="#comments">Comments</a></li>
<li><a href="#functions">Functions</a>
<ul>
<li><a href="#hoistings">Hoistings</a></li>
<li><a href="#returning-multiple-values">Returning multiple values</a></li>
</ul>
</li>
<li><a href="#symbol-visibility">Symbol visibility</a></li>
<li><a href="#variables">Variables</a>
<ul>
<li><a href="#mutable-variables">Mutable variables</a></li>
<li><a href="#initialization-vs-assignment">Initialization vs assignment</a></li>
<li><a href="#declaration-errors">Declaration errors</a></li>
</ul>
</li>
<li><a href="#v-types">V types</a>
<ul>
<li><a href="#primitive-types">Primitive types</a></li>
<li><a href="#strings">Strings</a></li>
<li><a href="#runes">Runes</a></li>
<li><a href="#numbers">Numbers</a></li>
<li><a href="#arrays">Arrays</a>
<ul>
<li><a href="#multidimensional-arrays">Multidimensional arrays</a></li>
<li><a href="#array-methods">Array methods</a></li>
<li><a href="#array-slices">Array slices</a></li>
</ul>
</li>
<li><a href="#fixed-size-arrays">Fixed size arrays</a></li>
<li><a href="#maps">Maps</a></li>
</ul>
</li>
</ul>
<p>&lt;/td&gt;&lt;td width=33% valign=top&gt;</p>
<ul>
<li><a href="#module-imports">Module imports</a>
<ul>
<li><a href="#selective-imports">Selective imports</a></li>
<li><a href="#module-import-aliasing">Module import aliasing</a></li>
</ul>
</li>
<li><a href="#statements--expressions">Statements &amp; expressions</a>
<ul>
<li><a href="#if">If</a></li>
<li><a href="#match">Match</a></li>
<li><a href="#in-operator">In operator</a></li>
<li><a href="#for-loop">For loop</a></li>
<li><a href="#defer">Defer</a></li>
<li><a href="#goto">Goto</a></li>
</ul>
</li>
<li><a href="#structs">Structs</a>
<ul>
<li><a href="#heap-structs">Heap structs</a></li>
<li><a href="#default-field-values">Default field values</a></li>
<li><a href="#required-fields">Required fields</a></li>
<li><a href="#short-struct-literal-syntax">Short struct literal syntax</a></li>
<li><a href="#struct-update-syntax">Struct update syntax</a></li>
<li><a href="#trailing-struct-literal-arguments">Trailing struct literal arguments</a></li>
<li><a href="#access-modifiers">Access modifiers</a></li>
<li><a href="#anonymous-structs">Anonymous structs</a></li>
<li><a href="#noinit-structs">[noinit] structs</a></li>
<li><a href="#methods">Methods</a></li>
<li><a href="#embedded-structs">Embedded structs</a></li>
</ul>
</li>
<li><a href="#unions">Unions</a></li>
</ul>
<p>&lt;/td&gt;&lt;td valign=top&gt;</p>
<ul>
<li><a href="#functions-2">Functions 2</a>
<ul>
<li><a href="#immutable-function-args-by-default">Immutable function args by default</a></li>
<li><a href="#mutable-arguments">Mutable arguments</a></li>
<li><a href="#variable-number-of-arguments">Variable number of arguments</a></li>
<li><a href="#anonymous--higher-order-functions">Anonymous &amp; higher-order functions</a></li>
<li><a href="#closures">Closures</a></li>
<li><a href="#parameter-evaluation-order">Parameter evaluation order</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
<li><a href="#constants">Constants</a>
<ul>
<li><a href="#required-module-prefix">Required module prefix</a></li>
</ul>
</li>
<li><a href="#builtin-functions">Builtin functions</a>
<ul>
<li><a href="#println">println</a></li>
<li><a href="#printing-custom-types">Printing custom types</a></li>
<li><a href="#dumping-expressions-at-runtime">Dumping expressions at runtime</a></li>
</ul>
</li>
<li><a href="#modules">Modules</a>
<ul>
<li><a href="#create-modules">Create modules</a></li>
<li><a href="#init-functions">init functions</a></li>
</ul>
</li>
</ul>
<p>&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=33% valign=top&gt;</p>
<ul>
<li><a href="#type-declarations">Type Declarations</a>
<ul>
<li><a href="#type-aliases">Type aliases</a></li>
<li><a href="#enums">Enums</a></li>
<li><a href="#function-types">Function Types</a></li>
<li><a href="#interfaces">Interfaces</a></li>
<li><a href="#sum-types">Sum types</a></li>
<li><a href="#optionresult-types-and-error-handling">Option/Result types &amp; error handling</a>
<ul>
<li><a href="#handling-optionsresults">Handling options/results</a></li>
</ul>
</li>
<li><a href="#custom-error-types">Custom error types</a></li>
<li><a href="#generics">Generics</a></li>
</ul>
</li>
<li><a href="#concurrency">Concurrency</a>
<ul>
<li><a href="#spawning-concurrent-tasks">Spawning Concurrent Tasks</a></li>
<li><a href="#channels">Channels</a></li>
<li><a href="#shared-objects">Shared Objects</a></li>
</ul>
</li>
<li><a href="#json">JSON</a>
<ul>
<li><a href="#decoding-json">Decoding JSON</a></li>
<li><a href="#encoding-json">Encoding JSON</a></li>
</ul>
</li>
<li><a href="#testing">Testing</a>
<ul>
<li><a href="#asserts">Asserts</a></li>
<li><a href="#asserts-with-an-extra-message">Asserts with an extra message</a></li>
<li><a href="#asserts-that-do-not-abort-your-program">Asserts that do not abort your program</a></li>
<li><a href="#test-files">Test files</a></li>
<li><a href="#running-tests">Running tests</a></li>
</ul>
</li>
<li><a href="#memory-management">Memory management</a>
<ul>
<li><a href="#control">Control</a></li>
<li><a href="#stack-and-heap">Stack and Heap</a></li>
</ul>
</li>
<li><a href="#orm">ORM</a></li>
<li><a href="#writing-documentation">Writing documentation</a>
<ul>
<li><a href="#newlines-in-documentation-comments">Newlines in Documentation Comments</a></li>
</ul>
</li>
</ul>
<p>&lt;/td&gt;&lt;td width=33% valign=top&gt;</p>
<ul>
<li><a href="#tools">Tools</a>
<ul>
<li><a href="#v-fmt">v fmt</a></li>
<li><a href="#v-shader">v shader</a></li>
<li><a href="#profiling">Profiling</a></li>
</ul>
</li>
<li><a href="#package-management">Package Management</a>
<ul>
<li><a href="#package-commands">Package commands</a></li>
<li><a href="#publish-package">Publish package</a></li>
</ul>
</li>
<li><a href="#advanced-topics">Advanced Topics</a>
<ul>
<li><a href="#attributes">Attributes</a></li>
<li><a href="#conditional-compilation">Conditional compilation</a>
<ul>
<li><a href="#compile-time-pseudo-variables">Compile time pseudo variables</a></li>
<li><a href="#compile-time-reflection">Compile-time reflection</a></li>
<li><a href="#compile-time-code">Compile time code</a></li>
<li><a href="#environment-specific-files">Environment specific files</a></li>
</ul>
</li>
<li><a href="#memory-unsafe-code">Memory-unsafe code</a></li>
<li><a href="#structs-with-reference-fields">Structs with reference fields</a></li>
<li><a href="#sizeof-and-__offsetof">sizeof and __offsetof</a></li>
<li><a href="#limited-operator-overloading">Limited operator overloading</a></li>
<li><a href="#performance-tuning">Performance tuning</a></li>
<li><a href="#atomics">Atomics</a></li>
<li><a href="#global-variables">Global Variables</a></li>
<li><a href="#cross-compilation">Cross compilation</a></li>
<li><a href="#debugging">Debugging</a>
<ul>
<li><a href="#c-backend-binaries-default">C Backend binaries Default</a></li>
<li><a href="#native-backend-binaries">Native Backend binaries</a></li>
<li><a href="#javascript-backend">Javascript Backend</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&lt;/td&gt;&lt;td valign=top&gt;</p>
<ul>
<li><a href="#v-and-c">V and C</a>
<ul>
<li><a href="#calling-c-from-v">Calling C from V</a></li>
<li><a href="#calling-v-from-c">Calling V from C</a></li>
<li><a href="#passing-c-compilation-flags">Passing C compilation flags</a></li>
<li><a href="#pkgconfig">#pkgconfig</a></li>
<li><a href="#including-c-code">Including C code</a></li>
<li><a href="#c-types">C types</a></li>
<li><a href="#c-declarations">C Declarations</a></li>
<li><a href="#export-to-shared-library">Export to shared library</a></li>
<li><a href="#translating-c-to-v">Translating C to V</a></li>
<li><a href="#working-around-c-issues">Working around C issues</a></li>
</ul>
</li>
<li><a href="#other-v-features">Other V Features</a>
<ul>
<li><a href="#inline-assembly">Inline assembly</a></li>
<li><a href="#hot-code-reloading">Hot code reloading</a></li>
<li><a href="#cross-platform-shell-scripts-in-v">Cross-platform shell scripts in V</a></li>
<li><a href="#vsh-scripts-with-no-extension">Vsh scripts with no extension</a></li>
</ul>
</li>
<li><a href="#appendices">Appendices</a>
<ul>
<li><a href="#appendix-i-keywords">Keywords</a></li>
<li><a href="#appendix-ii-operators">Operators</a></li>
</ul>
</li>
</ul>
<p>&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;</p>
<p>&lt;!--
Note: There are several special keywords, which you can put after the code fences for v:
compile, cgen, live, ignore, failcompile, okfmt, oksyntax, badsyntax, wip, nofmt
For more details, do: <code>v check-md</code>
--&gt;</p>
<h2 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world">#</a> Hello World</h2>
{% set code = "fn main() {\n	println('hello world')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Save this snippet into a file named <code>hello.v</code>. Now do: <code>v run hello.v</code>.</p>
<blockquote>
<p>That is assuming you have symlinked your V with <code>v symlink</code>, as described
<a href="https://github.com/vlang/v/blob/master/README.md#symlinking">here</a>.
If you haven't yet, you have to type the path to V manually.</p>
</blockquote>
<p>Congratulations - you just wrote and executed your first V program!</p>
<p>You can compile a program without execution with <code>v hello.v</code>.
See <code>v help</code> for all supported commands.</p>
<p>From the example above, you can see that functions are declared with the <code>fn</code> keyword.
The return type is specified after the function name.
In this case <code>main</code> doesn't return anything, so there is no return type.</p>
<p>As in many other languages (such as C, Go, and Rust), <code>main</code> is the entry point of your program.</p>
<p><a href="#println"><code>println</code></a> is one of the few <a href="#builtin-functions">built-in functions</a>.
It prints the value passed to it to standard output.</p>
<p><code>fn main()</code> declaration can be skipped in one file programs.
This is useful when writing small programs, &quot;scripts&quot;, or just learning the language.
For brevity, <code>fn main()</code> will be skipped in this tutorial.</p>
<p>This means that a &quot;hello world&quot; program in V is as simple as</p>
{% set code = "println('hello world')" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
If you do not use explicitly <code>fn main() {}</code>, you need to make sure, that all your
declarations, come before any variable assignment statements, or top level function calls,
since V will consider everything after the first assignment/function call as part of your
implicit main function.</p>
</blockquote>
<h2 id="running-a-project-folder-with-several-files"><a class="markdownIt-Anchor" href="#running-a-project-folder-with-several-files">#</a> Running a project folder with several files</h2>
<p>Suppose you have a folder with several .v files in it, where one of them
contains your <code>main()</code> function, and the other files have other helper
functions. They may be organized by topic, but still <em>not yet</em> structured
enough to be their own separate reusable modules, and you want to compile
them all into one program.</p>
<p>In other languages, you would have to use includes or a build system
to enumerate all files, compile them separately to object files,
then link them into one final executable.</p>
<p>In V however, you can compile and run the whole folder of .v files together,
using just <code>v run .</code>. Passing parameters also works, so you can
do: <code>v run . --yourparam some_other_stuff</code></p>
<p>The above will first compile your files into a single program (named
after your folder/project), and then it will execute the program with
<code>--yourparam some_other_stuff</code> passed to it as CLI parameters.</p>
<p>Your program can then use the CLI parameters like this:</p>
{% set code = "import os\n\nprintln(os.args)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
After a successful run, V will delete the generated executable.
If you want to keep it, use <code>v -keepc run .</code> instead, or just compile
manually with <code>v .</code> .</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>
Any V compiler flags should be passed <em>before</em> the <code>run</code> command.
Everything after the source file/folder, will be passed to the program
as is - it will not be processed by V.</p>
</blockquote>
<h2 id="comments"><a class="markdownIt-Anchor" href="#comments">#</a> Comments</h2>
{% set code = "// This is a single line comment.\n/*\nThis is a multiline comment.\n   /* It can be nested. */\n*/" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="functions"><a class="markdownIt-Anchor" href="#functions">#</a> Functions</h2>
{% set code = "fn main() {\n	println(add(77, 33))\n	println(sub(100, 50))\n}\n\nfn add(x int, y int) int {\n	return x + y\n}\n\nfn sub(x int, y int) int {\n	return x - y\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Again, the type comes after the argument's name.</p>
<p>Just like in Go and C, functions cannot be overloaded.
This simplifies the code and improves maintainability and readability.</p>
<h3 id="hoistings"><a class="markdownIt-Anchor" href="#hoistings">#</a> Hoistings</h3>
<p>Functions can be used before their declaration:
<code>add</code> and <code>sub</code> are declared after <code>main</code>, but can still be called from <code>main</code>.
This is true for all declarations in V and eliminates the need for header files
or thinking about the order of files and declarations.</p>
<h3 id="returning-multiple-values"><a class="markdownIt-Anchor" href="#returning-multiple-values">#</a> Returning multiple values</h3>
{% set code = "fn foo() (int, int) {\n	return 2, 3\n}\n\na, b := foo()\nprintln(a) // 2\nprintln(b) // 3\nc, _ := foo() // ignore values using `_`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="symbol-visibility"><a class="markdownIt-Anchor" href="#symbol-visibility">#</a> Symbol visibility</h2>
{% set code = "pub fn public_function() {\n}\n\nfn private_function() {\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Functions are private (not exported) by default.
To allow other <a href="#module-imports">modules</a> to use them, prepend <code>pub</code>. The same applies
to <a href="#structs">structs</a>, <a href="#constants">constants</a> and <a href="#type-declarations">types</a>.</p>
<blockquote>
<p><strong>Note</strong>
<code>pub</code> can only be used from a named module.
For information about creating a module, see <a href="#modules">Modules</a>.</p>
</blockquote>
<h2 id="variables"><a class="markdownIt-Anchor" href="#variables">#</a> Variables</h2>
{% set code = "name := 'Bob'\nage := 20\nlarge_number := i64(9999999999)\nprintln(name)\nprintln(age)\nprintln(large_number)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Variables are declared and initialized with <code>:=</code>. This is the only
way to declare variables in V. This means that variables always have an initial
value.</p>
<p>The variable's type is inferred from the value on the right hand side.
To choose a different type, use type conversion:
the expression <code>T(v)</code> converts the value <code>v</code> to the
type <code>T</code>.</p>
<p>Unlike most other languages, V only allows defining variables in functions.
By default V does not allow <strong>global variables</strong>. See more <a href="#global-variables">details</a>.</p>
<p>For consistency across different code bases, all variable and function names
must use the <code>snake_case</code> style, as opposed to type names, which must use <code>PascalCase</code>.</p>
<h3 id="mutable-variables"><a class="markdownIt-Anchor" href="#mutable-variables">#</a> Mutable variables</h3>
{% set code = "mut age := 20\nprintln(age)\nage = 21\nprintln(age)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>To change the value of the variable use <code>=</code>. In V, variables are
immutable by default.
To be able to change the value of the variable, you have to declare it with <code>mut</code>.</p>
<p>Try compiling the program above after removing <code>mut</code> from the first line.</p>
<h3 id="initialization-vs-assignment"><a class="markdownIt-Anchor" href="#initialization-vs-assignment">#</a> Initialization vs assignment</h3>
<p>Note the (important) difference between <code>:=</code> and <code>=</code>.
<code>:=</code> is used for declaring and initializing, <code>=</code> is used for assigning.</p>
{% set code = "fn main() {\n	age = 21\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This code will not compile, because the variable <code>age</code> is not declared.
All variables need to be declared in V.</p>
{% set code = "fn main() {\n	age := 21\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The values of multiple variables can be changed in one line.
In this way, their values can be swapped without an intermediary variable.</p>
{% set code = "mut a := 0\nmut b := 1\nprintln('${a}, ${b}') // 0, 1\na, b = b, a\nprintln('${a}, ${b}') // 1, 0" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="declaration-errors"><a class="markdownIt-Anchor" href="#declaration-errors">#</a> Declaration errors</h3>
<p>In development mode the compiler will warn you that you haven't used the variable
(you'll get an &quot;unused variable&quot; warning).
In production mode (enabled by passing the <code>-prod</code> flag to v ‚Äì <code>v -prod foo.v</code>)
it will not compile at all (like in Go).</p>
{% set code = "fn main() {\n	a := 10\n	if true {\n		a := 20 // error: redefinition of `a`\n	}\n	// warning: unused variable `a`\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Unlike most languages, variable shadowing is not allowed. Declaring a variable with a name
that is already used in a parent scope will cause a compilation error.</p>
<h2 id="v-types"><a class="markdownIt-Anchor" href="#v-types">#</a> V Types</h2>
<h3 id="primitive-types"><a class="markdownIt-Anchor" href="#primitive-types">#</a> Primitive types</h3>
{% set code = "bool\n\nstring\n\ni8    i16  int  i64      i128 (soon)\nu8    u16  u32  u64      u128 (soon)\n\nrune // represents a Unicode code point\n\nf32 f64\n\nisize, usize // platform-dependent, the size is how many bytes it takes to reference any location in memory\n\nvoidptr // this one is mostly used for [C interoperability](#v-and-c)\n\nany // similar to C's void* and Go's interface{}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
Unlike C and Go, <code>int</code> is always a 32 bit integer.</p>
</blockquote>
<p>There is an exception to the rule that all operators
in V must have values of the same type on both sides. A small primitive type
on one side can be automatically promoted if it fits
completely into the data range of the type on the other side.
These are the allowed possibilities:</p>
{% set code = "   i8 ‚Üí i16 ‚Üí int ‚Üí i64\n                  ‚Üò     ‚Üò\n                    f32 ‚Üí f64\n                  ‚Üó     ‚Üó\n   u8 ‚Üí u16 ‚Üí u32 ‚Üí u64 ‚¨é\n      ‚Üò     ‚Üò     ‚Üò      ptr\n   i8 ‚Üí i16 ‚Üí int ‚Üí i64 ‚¨è" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>An <code>int</code> value for example can be automatically promoted to <code>f64</code>
or <code>i64</code> but not to <code>u32</code>. (<code>u32</code> would mean loss of the sign for
negative values).
Promotion from <code>int</code> to <code>f32</code>, however, is currently done automatically
(but can lead to precision loss for large values).</p>
<p>Literals like <code>123</code> or <code>4.56</code> are treated in a special way. They do
not lead to type promotions, however they default to <code>int</code> and <code>f64</code>
respectively, when their type has to be decided:</p>
{% set code = "u := u16(12)\nv := 13 + u    // v is of type `u16` - no promotion\nx := f32(45.6)\ny := x + 3.14  // x is of type `f32` - no promotion\na := 75        // a is of type `int` - default for int literal\nb := 14.7      // b is of type `f64` - default for float literal\nc := u + a     // c is of type `int` - automatic promotion of `u`'s value\nd := b + x     // d is of type `f64` - automatic promotion of `x`'s value" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="strings"><a class="markdownIt-Anchor" href="#strings">#</a> Strings</h3>
{% set code = "name := 'Bob'\nassert name.len == 3       // will print 3\nassert name[0] == u8(66) // indexing gives a byte, u8(66) == `B`\nassert name[1..3] == 'ob'  // slicing gives a string 'ob'\n\n// escape codes\nwindows_newline := '\r\n'      // escape special characters like in C\nassert windows_newline.len == 2\n\n// arbitrary bytes can be directly specified using `\x##` notation where `#` is\n// a hex digit aardvark_str := '\x61ardvark' assert aardvark_str == 'aardvark'\nassert '\xc0'[0] == u8(0xc0)\n\n// or using octal escape `\###` notation where `#` is an octal digit\naardvark_str2 := '\141ardvark'\nassert aardvark_str2 == 'aardvark'\n\n// Unicode can be specified directly as `\u####` where # is a hex digit\n// and will be converted internally to its UTF-8 representation\nstar_str := '\u2605' // ‚òÖ\nassert star_str == '‚òÖ'\nassert star_str == '\xe2\x98\x85' // UTF-8 can be specified this way too." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>In V, a string is a read-only array of bytes. All Unicode characters are encoded using UTF-8:</p>
{% set code = "s := 'hello üåé' // emoji takes 4 bytes\nassert s.len == 10\n\narr := s.bytes() // convert `string` to `[]u8`\nassert arr.len == 10\n\ns2 := arr.bytestr() // convert `[]byte` to `string`\nassert s2 == s" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>String values are immutable. You cannot mutate elements:</p>
{% set code = "mut s := 'hello üåé'\ns[0] = `H` // not allowed" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p>error: cannot assign to <code>s[i]</code> since V strings are immutable</p>
</blockquote>
<p>Note that indexing a string will produce a <code>byte</code>, not a <code>rune</code> nor another <code>string</code>. Indexes
correspond to <em>bytes</em> in the string, not Unicode code points. If you want to convert the <code>byte</code> to a
<code>string</code>, use the <code>.ascii_str()</code> method on the <code>byte</code>:</p>
{% set code = "country := 'Netherlands'\nprintln(country[0]) // Output: 78\nprintln(country[0].ascii_str()) // Output: N" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Both single and double quotes can be used to denote strings. For consistency, <code>vfmt</code> converts double
quotes to single quotes unless the string contains a single quote character.</p>
<p>For raw strings, prepend <code>r</code>. Escape handling is not done for raw strings:</p>
{% set code = "s := r'hello\nworld' // the `\n` will be preserved as two characters\nprintln(s) // \"hello\nworld\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Strings can be easily converted to integers:</p>
{% set code = "s := '42'\nn := s.int() // 42\n\n// all int literals are supported\nassert '0xc3'.int() == 195\nassert '0o10'.int() == 8\nassert '0b1111_0000_1010'.int() == 3850\nassert '-0b1111_0000_1010'.int() == -3850" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>For more advanced <code>string</code> processing and conversions, refer to the
<a href="https://modules.vlang.io/strconv.html">vlib/strconv</a> module.</p>
<h4 id="string-interpolation"><a class="markdownIt-Anchor" href="#string-interpolation">#</a> String interpolation</h4>
<p>Basic interpolation syntax is pretty simple - use <code>${</code> before a variable name and <code>}</code> after. The
variable will be converted to a string and embedded into the literal:</p>
{% set code = "name := 'Bob'\nprintln('Hello, ${name}!') // Hello, Bob!" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>It also works with fields: <code>'age = ${user.age}'</code>. You may also use more complex expressions:
<code>'can register = ${user.age &gt; 13}'</code>.</p>
<p>Format specifiers similar to those in C's <code>printf()</code> are also supported. <code>f</code>, <code>g</code>, <code>x</code>, <code>o</code>, <code>b</code>,
etc. are optional and specify the output format. The compiler takes care of the storage size, so
there is no <code>hd</code> or <code>llu</code>.</p>
<p>To use a format specifier, follow this pattern:</p>
<p><code>${varname:[flags][width][.precision][type]}</code></p>
<ul>
<li>
<p>flags: may be zero or more of the following: <code>-</code> to left-align output within the field, <code>0</code> to use
<code>0</code> as the padding character instead of the default <code>space</code> character.</p>
<blockquote>
<p><strong>Note</strong>
V does not currently support the use of <code>'</code> or <code>#</code> as format flags, and V supports but
doesn't need <code>+</code> to right-align since that's the default.</p>
</blockquote>
</li>
<li>
<p>width: may be an integer value describing the minimum width of total field to output.</p>
</li>
<li>
<p>precision: an integer value preceded by a <code>.</code> will guarantee that many digits after the decimal
point, if the input variable is a float. Ignored if variable is an integer.</p>
</li>
<li>
<p>type: <code>f</code> and <code>F</code> specify the input is a float and should be rendered as such, <code>e</code> and <code>E</code> specify
the input is a float and should be rendered as an exponent (partially broken), <code>g</code> and <code>G</code> specify
the input is a float--the renderer will use floating point notation for small values and exponent
notation for large values, <code>d</code> specifies the input is an integer and should be rendered in base-10
digits, <code>x</code> and <code>X</code> require an integer and will render it as hexadecimal digits, <code>o</code> requires an
integer and will render it as octal digits, <code>b</code> requires an integer and will render it as binary
digits, <code>s</code> requires a string (almost never used).</p>
<blockquote>
<p><strong>Note</strong>
When a numeric type can render alphabetic characters, such as hex strings or special values
like <code>infinity</code>, the lowercase version of the type forces lowercase alphabetics and the
uppercase version forces uppercase alphabetics.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>
In most cases, it's best to leave the format type empty. Floats will be rendered by
default as <code>g</code>, integers will be rendered by default as <code>d</code>, and <code>s</code> is almost always redundant.
There are only three cases where specifying a type is recommended:</p>
</blockquote>
</li>
<li>
<p>format strings are parsed at compile time, so specifying a type can help detect errors then</p>
</li>
<li>
<p>format strings default to using lowercase letters for hex digits and the <code>e</code> in exponents. Use a
uppercase type to force the use of uppercase hex digits and an uppercase <code>E</code> in exponents.</p>
</li>
<li>
<p>format strings are the most convenient way to get hex, binary or octal strings from an integer.</p>
</li>
</ul>
<p>See
<a href="https://en.wikipedia.org/wiki/Printf_format_string#Format_placeholder_specification">Format Placeholder Specification</a>
for more information.</p>
{% set code = "x := 123.4567\nprintln('[${x:.2}]') // round to two decimal places => [123.46]\nprintln('[${x:10}]') // right-align with spaces on the left => [   123.457]\nprintln('[${int(x):-10}]') // left-align with spaces on the right => [123       ]\nprintln('[${int(x):010}]') // pad with zeros on the left => [0000000123]\nprintln('[${int(x):b}]') // output as binary => [1111011]\nprintln('[${int(x):o}]') // output as octal => [173]\nprintln('[${int(x):X}]') // output as uppercase hex => [7B]\n\nprintln('[${10.0000:.2}]') // remove insignificant 0s at the end => [10]\nprintln('[${10.0000:.2f}]') // do show the 0s at the end, even though they do not change the number => [10.00]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="string-operators"><a class="markdownIt-Anchor" href="#string-operators">#</a> String operators</h4>
{% set code = "name := 'Bob'\nbobby := name + 'by' // + is used to concatenate strings\nprintln(bobby) // \"Bobby\"\nmut s := 'hello '\ns += 'world' // `+=` is used to append to a string\nprintln(s) // \"hello world\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>All operators in V must have values of the same type on both sides. You cannot concatenate an
integer to a string:</p>
{% set code = "age := 10\nprintln('age = ' + age) // not allowed" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p>error: infix expr: cannot use <code>int</code> (right expression) as <code>string</code></p>
</blockquote>
<p>We have to either convert <code>age</code> to a <code>string</code>:</p>
{% set code = "age := 11\nprintln('age = ' + age.str())" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>or use string interpolation (preferred):</p>
{% set code = "age := 12\nprintln('age = ${age}')" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>See all methods of <a href="https://modules.vlang.io/index.html#string">string</a>
and related modules <a href="https://modules.vlang.io/strings.html">strings</a>,
<a href="https://modules.vlang.io/strconv.html">strconv</a>.</p>
<h3 id="runes"><a class="markdownIt-Anchor" href="#runes">#</a> Runes</h3>
<p>A <code>rune</code> represents a single Unicode character and is an alias for <code>u32</code>.
To denote them, use &lt;code&gt;`&lt;/code&gt; (backticks) :</p>
{% set code = "rocket := `üöÄ`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A <code>rune</code> can be converted to a UTF-8 string by using the <code>.str()</code> method.</p>
{% set code = "rocket := `üöÄ`\nassert rocket.str() == 'üöÄ'" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A <code>rune</code> can be converted to UTF-8 bytes by using the <code>.bytes()</code> method.</p>
{% set code = "rocket := `üöÄ`\nassert rocket.bytes() == [u8(0xf0), 0x9f, 0x9a, 0x80]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Hex, Unicode, and Octal escape sequences also work in a <code>rune</code> literal:</p>
{% set code = "assert `\x61` == `a`\nassert `\141` == `a`\nassert `\u0061` == `a`\n\n// multibyte literals work too\nassert `\u2605` == `‚òÖ`\nassert `\u2605`.bytes() == [u8(0xe2), 0x98, 0x85]\nassert `\xe2\x98\x85`.bytes() == [u8(0xe2), 0x98, 0x85]\nassert `\342\230\205`.bytes() == [u8(0xe2), 0x98, 0x85]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Note that <code>rune</code> literals use the same escape syntax as strings, but they can only hold one unicode
character. Therefore, if your code does not specify a single Unicode character, you will receive an
error at compile time.</p>
<p>Also remember that strings are indexed as bytes, not runes, so beware:</p>
{% set code = "rocket_string := 'üöÄ'\nassert rocket_string[0] != `üöÄ`\nassert 'aloha!'[0] == `a`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A string can be converted to runes by the <code>.runes()</code> method.</p>
{% set code = "hello := 'Hello World üëã'\nhello_runes := hello.runes() // [`H`, `e`, `l`, `l`, `o`, ` `, `W`, `o`, `r`, `l`, `d`, ` `, `üëã`]\nassert hello_runes.string() == hello" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="numbers"><a class="markdownIt-Anchor" href="#numbers">#</a> Numbers</h3>
{% set code = "a := 123" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This will assign the value of 123 to <code>a</code>. By default <code>a</code> will have the
type <code>int</code>.</p>
<p>You can also use hexadecimal, binary or octal notation for integer literals:</p>
{% set code = "a := 0x7B\nb := 0b01111011\nc := 0o173" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>All of these will be assigned the same value, 123. They will all have type
<code>int</code>, no matter what notation you used.</p>
<p>V also supports writing numbers with <code>_</code> as separator:</p>
{% set code = "num := 1_000_000 // same as 1000000\nthree := 0b0_11 // same as 0b11\nfloat_num := 3_122.55 // same as 3122.55\nhexa := 0xF_F // same as 255\noct := 0o17_3 // same as 0o173" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If you want a different type of integer, you can use casting:</p>
{% set code = "a := i64(123)\nb := u8(42)\nc := i16(12345)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Assigning floating point numbers works the same way:</p>
{% set code = "f := 1.0\nf1 := f64(3.14)\nf2 := f32(3.14)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If you do not specify the type explicitly, by default float literals
will have the type of <code>f64</code>.</p>
<p>Float literals can also be declared as a power of ten:</p>
{% set code = "f0 := 42e1 // 420\nf1 := 123e-2 // 1.23\nf2 := 456e+2 // 45600" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="arrays"><a class="markdownIt-Anchor" href="#arrays">#</a> Arrays</h3>
<p>An array is a collection of data elements of the same type. An array literal is a
list of expressions surrounded by square brackets. An individual element can be
accessed using an <em>index</em> expression. Indexes start from <code>0</code>:</p>
{% set code = "mut nums := [1, 2, 3]\nprintln(nums) // `[1, 2, 3]`\nprintln(nums[0]) // `1`\nprintln(nums[1]) // `2`\n\nnums[1] = 5\nprintln(nums) // `[1, 5, 3]`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>&lt;a id='array-operations'&gt;&lt;/a&gt;</p>
<p>An element can be appended to the end of an array using the push operator <code>&lt;&lt;</code>.
It can also append an entire array.</p>
{% set code = "mut nums := [1, 2, 3]\nnums << 4\nprintln(nums) // \"[1, 2, 3, 4]\"\n\n// append array\nnums << [5, 6, 7]\nprintln(nums) // \"[1, 2, 3, 4, 5, 6, 7]\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "mut names := ['John']\nnames << 'Peter'\nnames << 'Sam'\n// names << 10  <-- This will not compile. `names` is an array of strings." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>val in array</code> returns true if the array contains <code>val</code>. See <a href="#in-operator"><code>in</code> operator</a>.</p>
{% set code = "names := ['John', 'Peter', 'Sam']\nprintln('Alex' in names) // \"false\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="array-fields"><a class="markdownIt-Anchor" href="#array-fields">#</a> Array Fields</h4>
<p>There are two fields that control the &quot;size&quot; of an array:</p>
<ul>
<li><code>len</code>: <em>length</em> - the number of pre-allocated and initialized elements in the array</li>
<li><code>cap</code>: <em>capacity</em> - the amount of memory space which has been reserved for elements,
but not initialized or counted as elements. The array can grow up to this size without
being reallocated. Usually, V takes care of this field automatically but there are
cases where the user may want to do manual optimizations (see <a href="#array-initialization">below</a>).</li>
</ul>
{% set code = "mut nums := [1, 2, 3]\nprintln(nums.len) // \"3\"\nprintln(nums.cap) // \"3\" or greater\nnums = [] // The array is now empty\nprintln(nums.len) // \"0\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>data</code> is a field (of type <code>voidptr</code>) with the address of the first
element. This is for low-level <a href="#memory-unsafe-code"><code>unsafe</code></a> code.</p>
<blockquote>
<p><strong>Note</strong>
Fields are read-only and can't be modified by the user.</p>
</blockquote>
<h4 id="array-initialization"><a class="markdownIt-Anchor" href="#array-initialization">#</a> Array Initialization</h4>
<p>The type of an array is determined by the first element:</p>
<ul>
<li><code>[1, 2, 3]</code> is an array of ints (<code>[]int</code>).</li>
<li><code>['a', 'b']</code> is an array of strings (<code>[]string</code>).</li>
</ul>
<p>The user can explicitly specify the type for the first element: <code>[u8(16), 32, 64, 128]</code>.
V arrays are homogeneous (all elements must have the same type).
This means that code like <code>[1, 'a']</code> will not compile.</p>
<p>The above syntax is fine for a small number of known elements but for very large or empty
arrays there is a second initialization syntax:</p>
{% set code = "mut a := []int{len: 10000, cap: 30000, init: 3}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This creates an array of 10000 <code>int</code> elements that are all initialized with <code>3</code>. Memory
space is reserved for 30000 elements. The parameters <code>len</code>, <code>cap</code> and <code>init</code> are optional;
<code>len</code> defaults to <code>0</code> and <code>init</code> to the default initialization of the element type (<code>0</code>
for numerical type, <code>''</code> for <code>string</code>, etc). The run time system makes sure that the
capacity is not smaller than <code>len</code> (even if a smaller value is specified explicitly):</p>
{% set code = "arr := []int{len: 5, init: -1}\n// `arr == [-1, -1, -1, -1, -1]`, arr.cap == 5\n\n// Declare an empty array:\nusers := []int{}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Setting the capacity improves performance of pushing elements to the array
as reallocations can be avoided:</p>
{% set code = "mut numbers := []int{cap: 1000}\nprintln(numbers.len) // 0\n// Now appending elements won't reallocate\nfor i in 0 .. 1000 {\n	numbers << i\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
The above code uses a <a href="#range-for">range <code>for</code></a> statement.</p>
</blockquote>
<p>You can initialize the array by accessing the <code>it</code> variable which gives
the index as shown here:</p>
{% set code = "count := []int{len: 4, init: it}\nassert count == [0, 1, 2, 3]\n\nmut square := []int{len: 6, init: it * it}\n// square == [0, 1, 4, 9, 16, 25]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="array-types"><a class="markdownIt-Anchor" href="#array-types">#</a> Array Types</h4>
<p>An array can be of these types:</p>
<table>
<thead>
<tr>
<th>Types</th>
<th>Example Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number</td>
<td><code>[]int,[]i64</code></td>
</tr>
<tr>
<td>String</td>
<td><code>[]string</code></td>
</tr>
<tr>
<td>Rune</td>
<td><code>[]rune</code></td>
</tr>
<tr>
<td>Boolean</td>
<td><code>[]bool</code></td>
</tr>
<tr>
<td>Array</td>
<td><code>[][]int</code></td>
</tr>
<tr>
<td>Struct</td>
<td><code>[]MyStructName</code></td>
</tr>
<tr>
<td>Channel</td>
<td><code>[]chan f64</code></td>
</tr>
<tr>
<td>Function</td>
<td><code>[]MyFunctionType</code> <code>[]fn (int) bool</code></td>
</tr>
<tr>
<td>Interface</td>
<td><code>[]MyInterfaceName</code></td>
</tr>
<tr>
<td>Sum Type</td>
<td><code>[]MySumTypeName</code></td>
</tr>
<tr>
<td>Generic Type</td>
<td><code>[]T</code></td>
</tr>
<tr>
<td>Map</td>
<td><code>[]map[string]f64</code></td>
</tr>
<tr>
<td>Enum</td>
<td><code>[]MyEnumType</code></td>
</tr>
<tr>
<td>Alias</td>
<td><code>[]MyAliasTypeName</code></td>
</tr>
<tr>
<td>Thread</td>
<td><code>[]thread int</code></td>
</tr>
<tr>
<td>Reference</td>
<td><code>[]&amp;f64</code></td>
</tr>
<tr>
<td>Shared</td>
<td><code>[]shared MyStructType</code></td>
</tr>
</tbody>
</table>
<p><strong>Example Code:</strong></p>
<p>This example uses <a href="#structs">Structs</a> and <a href="#sum-types">Sum Types</a> to create an array
which can handle different types (e.g. Points, Lines) of data elements.</p>
{% set code = "struct Point {\n	x int\n	y int\n}\n\nstruct Line {\n	p1 Point\n	p2 Point\n}\n\ntype ObjectSumType = Line | Point\n\nmut object_list := []ObjectSumType{}\nobject_list << Point{1, 1}\nobject_list << Line{\n	p1: Point{3, 3}\n	p2: Point{4, 4}\n}\ndump(object_list)\n/*\nobject_list: [ObjectSumType(Point{\n    x: 1\n    y: 1\n}), ObjectSumType(Line{\n    p1: Point{\n        x: 3\n        y: 3\n    }\n    p2: Point{\n        x: 4\n        y: 4\n    }\n})]\n*/" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="multidimensional-arrays"><a class="markdownIt-Anchor" href="#multidimensional-arrays">#</a> Multidimensional Arrays</h4>
<p>Arrays can have more than one dimension.</p>
<p>2d array example:</p>
{% set code = "mut a := [][]int{len: 2, init: []int{len: 3}}\na[0][1] = 2\nprintln(a) // [[0, 2, 0], [0, 0, 0]]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>3d array example:</p>
{% set code = "mut a := [][][]int{len: 2, init: [][]int{len: 3, init: []int{len: 2}}}\na[0][1][1] = 2\nprintln(a) // [[[0, 0], [0, 2], [0, 0]], [[0, 0], [0, 0], [0, 0]]]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="array-methods"><a class="markdownIt-Anchor" href="#array-methods">#</a> Array methods</h4>
<p>All arrays can be easily printed with <code>println(arr)</code> and converted to a string
with <code>s := arr.str()</code>.</p>
<p>Copying the data from the array is done with <code>.clone()</code>:</p>
{% set code = "nums := [1, 2, 3]\nnums_copy := nums.clone()" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Arrays can be efficiently filtered and mapped with the <code>.filter()</code> and
<code>.map()</code> methods:</p>
{% set code = "nums := [1, 2, 3, 4, 5, 6]\neven := nums.filter(it % 2 == 0)\nprintln(even) // [2, 4, 6]\n// filter can accept anonymous functions\neven_fn := nums.filter(fn (x int) bool {\n	return x % 2 == 0\n})\nprintln(even_fn)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "words := ['hello', 'world']\nupper := words.map(it.to_upper())\nprintln(upper) // ['HELLO', 'WORLD']\n// map can also accept anonymous functions\nupper_fn := words.map(fn (w string) string {\n	return w.to_upper()\n})\nprintln(upper_fn) // ['HELLO', 'WORLD']" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>it</code> is a builtin variable which refers to the element currently being
processed in filter/map methods.</p>
<p>Additionally, <code>.any()</code> and <code>.all()</code> can be used to conveniently test
for elements that satisfy a condition.</p>
{% set code = "nums := [1, 2, 3]\nprintln(nums.any(it == 2)) // true\nprintln(nums.all(it >= 2)) // false" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>There are further built-in methods for arrays:</p>
<ul>
<li><code>a.repeat(n)</code> concatenates the array elements <code>n</code> times</li>
<li><code>a.insert(i, val)</code> inserts a new element <code>val</code> at index <code>i</code> and
shifts all following elements to the right</li>
<li><code>a.insert(i, [3, 4, 5])</code> inserts several elements</li>
<li><code>a.prepend(val)</code> inserts a value at the beginning, equivalent to <code>a.insert(0, val)</code></li>
<li><code>a.prepend(arr)</code> inserts elements of array <code>arr</code> at the beginning</li>
<li><code>a.trim(new_len)</code> truncates the length (if <code>new_length &lt; a.len</code>, otherwise does nothing)</li>
<li><code>a.clear()</code> empties the array without changing <code>cap</code> (equivalent to <code>a.trim(0)</code>)</li>
<li><code>a.delete_many(start, size)</code> removes <code>size</code> consecutive elements from index <code>start</code>
‚Äì triggers reallocation</li>
<li><code>a.delete(index)</code> equivalent to <code>a.delete_many(index, 1)</code></li>
<li><code>a.delete_last()</code> removes the last element</li>
<li><code>a.first()</code> equivalent to <code>a[0]</code></li>
<li><code>a.last()</code> equivalent to <code>a[a.len - 1]</code></li>
<li><code>a.pop()</code> removes the last element and returns it</li>
<li><code>a.reverse()</code> makes a new array with the elements of <code>a</code> in reverse order</li>
<li><code>a.reverse_in_place()</code> reverses the order of elements in <code>a</code></li>
<li><code>a.join(joiner)</code> concatenates an array of strings into one string
using <code>joiner</code> string as a separator</li>
</ul>
<p>See all methods of <a href="https://modules.vlang.io/index.html#array">array</a></p>
<p>See also <a href="https://modules.vlang.io/arrays.html">vlib/arrays</a>.</p>
<h5 id="sorting-arrays"><a class="markdownIt-Anchor" href="#sorting-arrays">#</a> Sorting Arrays</h5>
<p>Sorting arrays of all kinds is very simple and intuitive. Special variables <code>a</code> and <code>b</code>
are used when providing a custom sorting condition.</p>
{% set code = "mut numbers := [1, 3, 2]\nnumbers.sort() // 1, 2, 3\nnumbers.sort(a > b) // 3, 2, 1" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "struct User {\n	age  int\n	name string\n}\n\nmut users := [User{21, 'Bob'}, User{20, 'Zarkon'}, User{25, 'Alice'}]\nusers.sort(a.age < b.age) // sort by User.age int field\nusers.sort(a.name > b.name) // reverse sort by User.name string field" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V also supports custom sorting, through the <code>sort_with_compare</code> array method.
Which expects a comparing function which will define the sort order.
Useful for sorting on multiple fields at the same time by custom sorting rules.
The code below sorts the array ascending on <code>name</code> and descending <code>age</code>.</p>
{% set code = "struct User {\n	age  int\n	name string\n}\n\nmut users := [User{21, 'Bob'}, User{65, 'Bob'}, User{25, 'Alice'}]\n\ncustom_sort_fn := fn (a &User, b &User) int {\n	// return -1 when a comes before b\n	// return 0, when both are in same order\n	// return 1 when b comes before a\n	if a.name == b.name {\n		if a.age < b.age {\n			return 1\n		}\n		if a.age > b.age {\n			return -1\n		}\n		return 0\n	}\n	if a.name < b.name {\n		return -1\n	} else if a.name > b.name {\n		return 1\n	}\n	return 0\n}\nusers.sort_with_compare(custom_sort_fn)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="array-slices"><a class="markdownIt-Anchor" href="#array-slices">#</a> Array Slices</h4>
<p>A slice is a part of a parent array. Initially it refers to the elements
between two indices separated by a <code>..</code> operator. The right-side index must
be greater than or equal to the left side index.</p>
<p>If a right-side index is absent, it is assumed to be the array length. If a
left-side index is absent, it is assumed to be 0.</p>
{% set code = "nums := [0, 10, 20, 30, 40]\nprintln(nums[1..4]) // [10, 20, 30]\nprintln(nums[..4]) // [0, 10, 20, 30]\nprintln(nums[1..]) // [10, 20, 30, 40]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>In V slices are arrays themselves (they are not distinct types). As a result
all array operations may be performed on them. E.g. they can be pushed onto an
array of the same type:</p>
{% set code = "array_1 := [3, 5, 4, 7, 6]\nmut array_2 := [0, 1]\narray_2 << array_1[..3]\nprintln(array_2) // `[0, 1, 3, 5, 4]`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A slice is always created with the smallest possible capacity <code>cap == len</code> (see
<a href="#array-initialization"><code>cap</code> above</a>) no matter what the capacity or length
of the parent array is. As a result it is immediately reallocated and copied to another
memory location when the size increases thus becoming independent from the
parent array (<em>copy on grow</em>). In particular pushing elements to a slice
does not alter the parent:</p>
{% set code = "mut a := [0, 1, 2, 3, 4, 5]\nmut b := a[2..4]\nb[0] = 7 // `b[0]` is referring to `a[2]`\nprintln(a) // `[0, 1, 7, 3, 4, 5]`\nb << 9\n// `b` has been reallocated and is now independent from `a`\nprintln(a) // `[0, 1, 7, 3, 4, 5]` - no change\nprintln(b) // `[7, 3, 9]`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Appending to the parent array may or may not make it independent from its child slices.
The behaviour depends on the parent's capacity and is predictable:</p>
{% set code = "mut a := []int{len: 5, cap: 6, init: 2}\nmut b := a[1..4]\na << 3\n// no reallocation - fits in `cap`\nb[2] = 13 // `a[3]` is modified\na << 4\n// a has been reallocated and is now independent from `b` (`cap` was exceeded)\nb[1] = 3 // no change in `a`\nprintln(a) // `[2, 2, 2, 13, 2, 3, 4]`\nprintln(b) // `[2, 3, 13]`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can call .clone() on the slice, if you do want to have an independent copy right away:</p>
{% set code = "mut a := [0, 1, 2, 3, 4, 5]\nmut b := a[2..4].clone()\nb[0] = 7 // Note: `b[0]` is NOT referring to `a[2]`, as it would have been, without the .clone()\nprintln(a) // [0, 1, 2, 3, 4, 5]\nprintln(b) // [7, 3]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h5 id="slices-with-negative-indexes"><a class="markdownIt-Anchor" href="#slices-with-negative-indexes">#</a> Slices with negative indexes</h5>
<p>V supports array and string slices with negative indexes.
Negative indexing starts from the end of the array towards the start,
for example <code>-3</code> is equal to <code>array.len - 3</code>.
Negative slices have a different syntax from normal slices, i.e. you need
to add a <code>gate</code> between the array name and the square bracket: <code>a#[..-3]</code>.
The <code>gate</code> specifies that this is a different type of slice and remember that
the result is &quot;locked&quot; inside the array.
The returned slice is always a valid array, though it may be empty:</p>
{% set code = "a := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprintln(a#[-3..]) // [7, 8, 9]\nprintln(a#[-20..]) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprintln(a#[-20..-8]) // [0, 1]\nprintln(a#[..-3]) // [0, 1, 2, 3, 4, 5, 6]\n\n// empty arrays\nprintln(a#[-20..-10]) // []\nprintln(a#[20..10]) // []\nprintln(a#[20..30]) // []" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="array-method-chaining"><a class="markdownIt-Anchor" href="#array-method-chaining">#</a> Array method chaining</h4>
<p>You can chain the calls of array methods like <code>.filter()</code> and <code>.map()</code> and use
the <code>it</code> built-in variable to achieve a classic <code>map/filter</code> functional paradigm:</p>
{% set code = "// using filter, map and negatives array slices\nfiles := ['pippo.jpg', '01.bmp', '_v.txt', 'img_02.jpg', 'img_01.JPG']\nfiltered := files.filter(it#[-4..].to_lower() == '.jpg').map(it.to_upper())\n// ['PIPPO.JPG', 'IMG_02.JPG', 'IMG_01.JPG']" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="fixed-size-arrays"><a class="markdownIt-Anchor" href="#fixed-size-arrays">#</a> Fixed size arrays</h3>
<p>V also supports arrays with fixed size. Unlike ordinary arrays, their
length is constant. You cannot append elements to them, nor shrink them.
You can only modify their elements in place.</p>
<p>However, access to the elements of fixed size arrays is more efficient,
they need less memory than ordinary arrays, and unlike ordinary arrays,
their data is on the stack, so you may want to use them as buffers if you
do not want additional heap allocations.</p>
<p>Most methods are defined to work on ordinary arrays, not on fixed size arrays.
You can convert a fixed size array to an ordinary array with slicing:</p>
{% set code = "mut fnums := [3]int{} // fnums is a fixed size array with 3 elements.\nfnums[0] = 1\nfnums[1] = 10\nfnums[2] = 100\nprintln(fnums) // => [1, 10, 100]\nprintln(typeof(fnums).name) // => [3]int\n\nfnums2 := [1, 10, 100]! // short init syntax that does the same (the syntax will probably change)\n\nanums := fnums[..] // same as `anums := fnums[0..fnums.len]`\nprintln(anums) // => [1, 10, 100]\nprintln(typeof(anums).name) // => []int" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Note that slicing will cause the data of the fixed size array to be copied to
the newly created ordinary array.</p>
<h3 id="maps"><a class="markdownIt-Anchor" href="#maps">#</a> Maps</h3>
{% set code = "mut m := map[string]int{} // a map with `string` keys and `int` values\nm['one'] = 1\nm['two'] = 2\nprintln(m['one']) // \"1\"\nprintln(m['bad_key']) // \"0\"\nprintln('bad_key' in m) // Use `in` to detect whether such key exists\nprintln(m.keys()) // ['one', 'two']\nm.delete('two')" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Maps can have keys of type string, rune, integer, float or voidptr.</p>
<p>The whole map can be initialized using this short syntax:</p>
{% set code = "numbers := {\n	'one': 1\n	'two': 2\n}\nprintln(numbers)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If a key is not found, a zero value is returned by default:</p>
{% set code = "sm := {\n	'abc': 'xyz'\n}\nval := sm['bad_key']\nprintln(val) // ''" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "intm := {\n	1: 1234\n	2: 5678\n}\ns := intm[3]\nprintln(s) // 0" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>It's also possible to use an <code>or {}</code> block to handle missing keys:</p>
{% set code = "mm := map[string]int{}\nval := mm['bad_key'] or { panic('key not found') }" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can also check, if a key is present, and get its value, if it was present, in one go:</p>
{% set code = "m := {\n	'abc': 'def'\n}\nif v := m['abc'] {\n	println('the map value for that key is: ${v}')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The same option check applies to arrays:</p>
{% set code = "arr := [1, 2, 3]\nlarge_index := 999\nval := arr[large_index] or { panic('out of bounds') }\nprintln(val)\n// you can also do this, if you want to *propagate* the access error:\nval2 := arr[333]!\nprintln(val2)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V also supports nested maps:</p>
{% set code = "mut m := map[string]map[string]int{}\nm['greet'] = {\n	'Hello': 1\n}\nm['place'] = {\n	'world': 2\n}\nm['code']['orange'] = 123\nprint(m)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Maps are ordered by insertion, like dictionaries in Python. The order is a
guaranteed language feature. This may change in the future.</p>
<p>See all methods of
<a href="https://modules.vlang.io/index.html#map">map</a>
and
<a href="https://modules.vlang.io/maps.html">maps</a>.</p>
<h2 id="module-imports"><a class="markdownIt-Anchor" href="#module-imports">#</a> Module imports</h2>
<p>For information about creating a module, see <a href="#modules">Modules</a>.</p>
<p>Modules can be imported using the <code>import</code> keyword:</p>
{% set code = "import os\n\nfn main() {\n	// read text from stdin\n	name := os.input('Enter your name: ')\n	println('Hello, ${name}!')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This program can use any public definitions from the <code>os</code> module, such
as the <code>input</code> function. See the <a href="https://modules.vlang.io/">standard library</a>
documentation for a list of common modules and their public symbols.</p>
<p>By default, you have to specify the module prefix every time you call an external function.
This may seem verbose at first, but it makes code much more readable
and easier to understand - it's always clear which function from
which module is being called. This is especially useful in large code bases.</p>
<p>Cyclic module imports are not allowed, like in Go.</p>
<h3 id="selective-imports"><a class="markdownIt-Anchor" href="#selective-imports">#</a> Selective imports</h3>
<p>You can also import specific functions and types from modules directly:</p>
{% set code = "import os { input }\n\nfn main() {\n	// read text from stdin\n	name := input('Enter your name: ')\n	println('Hello, ${name}!')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
This will import the module as well. Also, this is not allowed for
constants - they must always be prefixed.</p>
</blockquote>
<p>You can import several specific symbols at once:</p>
{% set code = "import os { input, user_os }\n\nname := input('Enter your name: ')\nprintln('Name: ${name}')\ncurrent_os := user_os()\nprintln('Your OS is ${current_os}.')" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="module-import-aliasing"><a class="markdownIt-Anchor" href="#module-import-aliasing">#</a> Module import aliasing</h3>
<p>Any imported module name can be aliased using the <code>as</code> keyword:</p>
<blockquote>
<p><strong>Note</strong>
This example will not compile unless you have created <code>mymod/sha256.v</code></p>
</blockquote>
{% set code = "import crypto.sha256\nimport mymod.sha256 as mysha256\n\nfn main() {\n	v_hash := sha256.sum('hi'.bytes()).hex()\n	my_hash := mysha256.sum('hi'.bytes()).hex()\n	assert my_hash == v_hash\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You cannot alias an imported function or type.
However, you <em>can</em> redeclare a type.</p>
{% set code = "import time\nimport math\n\ntype MyTime = time.Time\n\nfn (mut t MyTime) century() int {\n	return int(1.0 + math.trunc(f64(t.year) * 0.009999794661191))\n}\n\nfn main() {\n	mut my_time := MyTime{\n		year: 2020\n		month: 12\n		day: 25\n	}\n	println(time.new_time(my_time).utc_string())\n	println('Century: ${my_time.century()}')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="statements-expressions"><a class="markdownIt-Anchor" href="#statements-expressions">#</a> Statements &amp; expressions</h2>
<h3 id="if"><a class="markdownIt-Anchor" href="#if">#</a> If</h3>
{% set code = "a := 10\nb := 20\nif a < b {\n	println('${a} < ${b}')\n} else if a > b {\n	println('${a} > ${b}')\n} else {\n	println('${a} == ${b}')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>if</code> statements are pretty straightforward and similar to most other languages.
Unlike other C-like languages,
there are no parentheses surrounding the condition and the braces are always required.</p>
<p><code>if</code> can be used as an expression:</p>
{% set code = "num := 777\ns := if num % 2 == 0 { 'even' } else { 'odd' }\nprintln(s)\n// \"odd\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="type-checks-and-casts"><a class="markdownIt-Anchor" href="#type-checks-and-casts">#</a> Type checks and casts</h4>
<p>You can check the current type of a sum type using <code>is</code> and its negated form <code>!is</code>.</p>
<p>You can do it either in an <code>if</code>:</p>
{% set code = "struct Abc {\n	val string\n}\n\nstruct Xyz {\n	foo string\n}\n\ntype Alphabet = Abc | Xyz\n\nx := Alphabet(Abc{'test'}) // sum type\nif x is Abc {\n	// x is automatically casted to Abc and can be used here\n	println(x)\n}\nif x !is Abc {\n	println('Not Abc')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>or using <code>match</code>:</p>
{% set code = "match x {\n	Abc {\n		// x is automatically casted to Abc and can be used here\n		println(x)\n	}\n	Xyz {\n		// x is automatically casted to Xyz and can be used here\n		println(x)\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This works also with struct fields:</p>
{% set code = "struct MyStruct {\n	x int\n}\n\nstruct MyStruct2 {\n	y string\n}\n\ntype MySumType = MyStruct | MyStruct2\n\nstruct Abc {\n	bar MySumType\n}\n\nx := Abc{\n	bar: MyStruct{123} // MyStruct will be converted to MySumType type automatically\n}\nif x.bar is MyStruct {\n	// x.bar is automatically casted\n	println(x.bar)\n} else if x.bar is MyStruct2 {\n	new_var := x.bar as MyStruct2\n	// ... or you can use `as` to create a type cast an alias manually:\n	println(new_var)\n}\nmatch x.bar {\n	MyStruct {\n		// x.bar is automatically casted\n		println(x.bar)\n	}\n	else {}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Mutable variables can change, and doing a cast would be unsafe.
However, sometimes it's useful to type cast despite mutability.
In such cases the developer must mark the expression with the <code>mut</code> keyword
to tell the compiler that they know what they're doing.</p>
<p>It works like this:</p>
{% set code = "mut x := MySumType(MyStruct{123})\nif mut x is MyStruct {\n	// x is casted to MyStruct even if it's mutable\n	// without the mut keyword that wouldn't work\n	println(x)\n}\n// same with match\nmatch mut x {\n	MyStruct {\n		// x is casted to MyStruct even if it's mutable\n		// without the mut keyword that wouldn't work\n		println(x)\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="match"><a class="markdownIt-Anchor" href="#match">#</a> Match</h3>
{% set code = "os := 'windows'\nprint('V is running on ')\nmatch os {\n	'darwin' { println('macOS.') }\n	'linux' { println('Linux.') }\n	else { println(os) }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A match statement is a shorter way to write a sequence of <code>if - else</code> statements.
When a matching branch is found, the following statement block will be run.
The else branch will be run when no other branches match.</p>
{% set code = "number := 2\ns := match number {\n	1 { 'one' }\n	2 { 'two' }\n	else { 'many' }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A match statement can also to be used as an <code>if - else if - else</code> alternative:</p>
{% set code = "match true {\n	2 > 4 { println('if') }\n	3 == 4 { println('else if') }\n	2 == 2 { println('else if2') }\n	else { println('else') }\n}\n// 'else if2' should be printed" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>or as an <code>unless</code> alternative: <a href="https://www.tutorialspoint.com/ruby/ruby_if_else.htm">unless Ruby</a></p>
{% set code = "match false {\n	2 > 4 { println('if') }\n	3 == 4 { println('else if') }\n	2 == 2 { println('else if2') }\n	else { println('else') }\n}\n// 'if' should be printed" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A match expression returns the value of the final expression from the matching branch.</p>
{% set code = "enum Color {\n	red\n	blue\n	green\n}\n\nfn is_red_or_blue(c Color) bool {\n	return match c {\n		.red, .blue { true } // comma can be used to test multiple values\n		.green { false }\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A match statement can also be used to branch on the variants of an <code>enum</code>
by using the shorthand <code>.variant_here</code> syntax. An <code>else</code> branch is not allowed
when all the branches are exhaustive.</p>
{% set code = "c := `v`\ntyp := match c {\n	`0`...`9` { 'digit' }\n	`A`...`Z` { 'uppercase' }\n	`a`...`z` { 'lowercase' }\n	else { 'other' }\n}\nprintln(typ)\n// 'lowercase'" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can also use ranges as <code>match</code> patterns. If the value falls within the range
of a branch, that branch will be executed.</p>
<p>Note that the ranges use <code>...</code> (three dots) rather than <code>..</code> (two dots). This is
because the range is <em>inclusive</em> of the last element, rather than exclusive
(as <code>..</code> ranges are). Using <code>..</code> in a match branch will throw an error.</p>
{% set code = "const start = 1\n\nconst end = 10\n\nc := 2\nnum := match c {\n	start...end {\n		1000\n	}\n	else {\n		0\n	}\n}\nprintln(num)\n// 1000" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Constants can also be used in the range branch expressions.</p>
<blockquote>
<p><strong>Note</strong>
<code>match</code> as an expression is not usable in <code>for</code> loop and <code>if</code> statements.</p>
</blockquote>
<h3 id="in-operator"><a class="markdownIt-Anchor" href="#in-operator">#</a> In operator</h3>
<p><code>in</code> allows to check whether an array or a map contains an element.
To do the opposite, use <code>!in</code>.</p>
{% set code = "nums := [1, 2, 3]\nprintln(1 in nums) // true\nprintln(4 !in nums) // true\nm := {\n	'one': 1\n	'two': 2\n}\nprintln('one' in m) // true\nprintln('three' !in m) // true" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>It's also useful for writing boolean expressions that are clearer and more compact:</p>
{% set code = "enum Token {\n	plus\n	minus\n	div\n	mult\n}\n\nstruct Parser {\n	token Token\n}\n\nparser := Parser{}\nif parser.token == .plus || parser.token == .minus || parser.token == .div || parser.token == .mult {\n	// ...\n}\nif parser.token in [.plus, .minus, .div, .mult] {\n	// ...\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V optimizes such expressions,
so both <code>if</code> statements above produce the same machine code and no arrays are created.</p>
<h3 id="for-loop"><a class="markdownIt-Anchor" href="#for-loop">#</a> For loop</h3>
<p>V has only one looping keyword: <code>for</code>, with several forms.</p>
<h4 id="forin"><a class="markdownIt-Anchor" href="#forin">#</a> <code>for</code>/<code>in</code></h4>
<p>This is the most common form. You can use it with an array, map or
numeric range.</p>
<h5 id="array-for"><a class="markdownIt-Anchor" href="#array-for">#</a> Array <code>for</code></h5>
{% set code = "numbers := [1, 2, 3, 4, 5]\nfor num in numbers {\n	println(num)\n}\nnames := ['Sam', 'Peter']\nfor i, name in names {\n	println('${i}) ${name}')\n	// Output: 0) Sam\n	//         1) Peter\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The <code>for value in arr</code> form is used for going through elements of an array.
If an index is required, an alternative form <code>for index, value in arr</code> can be used.</p>
<p>Note, that the value is read-only.
If you need to modify the array while looping, you need to declare the element as mutable:</p>
{% set code = "mut numbers := [0, 1, 2]\nfor mut num in numbers {\n	num++\n}\nprintln(numbers) // [1, 2, 3]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>When an identifier is just a single underscore, it is ignored.</p>
<h5 id="custom-iterators"><a class="markdownIt-Anchor" href="#custom-iterators">#</a> Custom iterators</h5>
<p>Types that implement a <code>next</code> method returning an <code>Option</code> can be iterated
with a <code>for</code> loop.</p>
{% set code = "struct SquareIterator {\n	arr []int\nmut:\n	idx int\n}\n\nfn (mut iter SquareIterator) next() ?int {\n	if iter.idx >= iter.arr.len {\n		return none\n	}\n	defer {\n		iter.idx++\n	}\n	return iter.arr[iter.idx] * iter.arr[iter.idx]\n}\n\nnums := [1, 2, 3, 4, 5]\niter := SquareIterator{\n	arr: nums\n}\nfor squared in iter {\n	println(squared)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The code above prints:</p>
{% set code = "1\n4\n9\n16\n25" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h5 id="map-for"><a class="markdownIt-Anchor" href="#map-for">#</a> Map <code>for</code></h5>
{% set code = "m := {\n	'one': 1\n	'two': 2\n}\nfor key, value in m {\n	println('${key} -> ${value}')\n	// Output: one -> 1\n	//         two -> 2\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Either key or value can be ignored by using a single underscore as the identifier.</p>
{% set code = "m := {\n	'one': 1\n	'two': 2\n}\n// iterate over keys\nfor key, _ in m {\n	println(key)\n	// Output: one\n	//         two\n}\n// iterate over values\nfor _, value in m {\n	println(value)\n	// Output: 1\n	//         2\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h5 id="range-for"><a class="markdownIt-Anchor" href="#range-for">#</a> Range <code>for</code></h5>
{% set code = "// Prints '01234'\nfor i in 0 .. 5 {\n	print(i)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>low..high</code> means an <em>exclusive</em> range, which represents all values
from <code>low</code> up to <em>but not including</em> <code>high</code>.</p>
<h4 id="condition-for"><a class="markdownIt-Anchor" href="#condition-for">#</a> Condition <code>for</code></h4>
{% set code = "mut sum := 0\nmut i := 0\nfor i <= 100 {\n	sum += i\n	i++\n}\nprintln(sum) // \"5050\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This form of the loop is similar to <code>while</code> loops in other languages.
The loop will stop iterating once the boolean condition evaluates to false.
Again, there are no parentheses surrounding the condition, and the braces are always required.</p>
<h4 id="bare-for"><a class="markdownIt-Anchor" href="#bare-for">#</a> Bare <code>for</code></h4>
{% set code = "mut num := 0\nfor {\n	num += 2\n	if num >= 10 {\n		break\n	}\n}\nprintln(num) // \"10\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The condition can be omitted, resulting in an infinite loop.</p>
<h4 id="c-for"><a class="markdownIt-Anchor" href="#c-for">#</a> C <code>for</code></h4>
{% set code = "for i := 0; i < 10; i += 2 {\n	// Don't print 6\n	if i == 6 {\n		continue\n	}\n	println(i)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Finally, there's the traditional C style <code>for</code> loop. It's safer than the <code>while</code> form
because with the latter it's easy to forget to update the counter and get
stuck in an infinite loop.</p>
<p>Here <code>i</code> doesn't need to be declared with <code>mut</code> since it's always going to be mutable by definition.</p>
<h4 id="labelled-break-continue"><a class="markdownIt-Anchor" href="#labelled-break-continue">#</a> Labelled break &amp; continue</h4>
<p><code>break</code> and <code>continue</code> control the innermost <code>for</code> loop by default.
You can also use <code>break</code> and <code>continue</code> followed by a label name to refer to an outer <code>for</code>
loop:</p>
{% set code = "outer: for i := 4; true; i++ {\n	println(i)\n	for {\n		if i < 7 {\n			continue outer\n		} else {\n			break outer\n		}\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The label must immediately precede the outer loop.
The above code prints:</p>
{% set code = "4\n5\n6\n7" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="defer"><a class="markdownIt-Anchor" href="#defer">#</a> Defer</h3>
<p>A defer statement defers the execution of a block of statements
until the surrounding function returns.</p>
{% set code = "import os\n\nfn read_log() {\n	mut ok := false\n	mut f := os.open('log.txt') or { panic(err) }\n	defer {\n		f.close()\n	}\n	// ...\n	if !ok {\n		// defer statement will be called here, the file will be closed\n		return\n	}\n	// ...\n	// defer statement will be called here, the file will be closed\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If the function returns a value the <code>defer</code> block is executed <em>after</em> the return
expression is evaluated:</p>
{% set code = "import os\n\nenum State {\n	normal\n	write_log\n	return_error\n}\n\n// write log file and return number of bytes written\n\nfn write_log(s State) !int {\n	mut f := os.create('log.txt')!\n	defer {\n		f.close()\n	}\n	if s == .write_log {\n		// `f.close()` will be called after `f.write()` has been\n		// executed, but before `write_log()` finally returns the\n		// number of bytes written to `main()`\n		return f.writeln('This is a log file')\n	} else if s == .return_error {\n		// the file will be closed after the `error()` function\n		// has returned - so the error message will still report\n		// it as open\n		return error('nothing written; file open: ${f.is_opened}')\n	}\n	// the file will be closed here, too\n	return 0\n}\n\nfn main() {\n	n := write_log(.return_error) or {\n		println('Error: ${err}')\n		0\n	}\n	println('${n} bytes written')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="goto"><a class="markdownIt-Anchor" href="#goto">#</a> Goto</h3>
<p>V allows unconditionally jumping to a label with <code>goto</code>. The label name must be contained
within the same function as the <code>goto</code> statement. A program may <code>goto</code> a label outside
or deeper than the current scope. <code>goto</code> allows jumping past variable initialization or
jumping back to code that accesses memory that has already been freed, so it requires
<code>unsafe</code>.</p>
{% set code = "if x {\n	// ...\n	if y {\n		unsafe {\n			goto my_label\n		}\n	}\n	// ...\n}\nmy_label:" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>goto</code> should be avoided, particularly when <code>for</code> can be used instead.
<a href="#labelled-break--continue">Labelled break/continue</a> can be used to break out of
a nested loop, and those do not risk violating memory-safety.</p>
<h2 id="structs"><a class="markdownIt-Anchor" href="#structs">#</a> Structs</h2>
{% set code = "struct Point {\n	x int\n	y int\n}\n\nmut p := Point{\n	x: 10\n	y: 20\n}\nprintln(p.x) // Struct fields are accessed using a dot\n// Alternative literal syntax for structs with 3 fields or fewer\np = Point{10, 20}\nassert p.x == 10" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="heap-structs"><a class="markdownIt-Anchor" href="#heap-structs">#</a> Heap structs</h3>
<p>Structs are allocated on the stack. To allocate a struct on the heap
and get a <a href="#references">reference</a> to it, use the <code>&amp;</code> prefix:</p>
{% set code = "struct Point {\n	x int\n	y int\n}\n\np := &Point{10, 10}\n// References have the same syntax for accessing fields\nprintln(p.x)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The type of <code>p</code> is <code>&amp;Point</code>. It's a <a href="#references">reference</a> to <code>Point</code>.
References are similar to Go pointers and C++ references.</p>
{% set code = "struct Foo {\nmut:\n	x int\n}\n\nfa := Foo{1}\nmut a := fa\na.x = 2\nassert fa.x == 1\nassert a.x == 2\n\n// fb := Foo{ 1 }\n// mut b := &fb  // error: `fb` is immutable, cannot have a mutable reference to it\n// b.x = 2\n\nmut fc := Foo{1}\nmut c := &fc\nc.x = 2\nassert fc.x == 2\nassert c.x == 2\nprintln(fc) // Foo{ x: 2 }\nprintln(c) // &Foo{ x: 2 } // Note `&` prefixed." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>see also <a href="#stack-and-heap">Stack and Heap</a></p>
<h3 id="default-field-values"><a class="markdownIt-Anchor" href="#default-field-values">#</a> Default field values</h3>
{% set code = "struct Foo {\n	n   int    // n is 0 by default\n	s   string // s is '' by default\n	a   []int  // a is `[]int{}` by default\n	pos int = -1 // custom default value\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>All struct fields are zeroed by default during the creation of the struct.
Array and map fields are allocated.
In case of reference value, <a href="#structs-with-reference-fields">see</a>.</p>
<p>It's also possible to define custom default values.</p>
<h3 id="required-fields"><a class="markdownIt-Anchor" href="#required-fields">#</a> Required fields</h3>
{% set code = "struct Foo {\n	n int [required]\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can mark a struct field with the <code>[required]</code> <a href="#attributes">attribute</a>, to tell V that
that field must be initialized when creating an instance of that struct.</p>
<p>This example will not compile, since the field <code>n</code> isn't explicitly initialized:</p>
{% set code = "_ = Foo{}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>&lt;a id='short-struct-initialization-syntax'&gt;&lt;/a&gt;</p>
<h3 id="short-struct-literal-syntax"><a class="markdownIt-Anchor" href="#short-struct-literal-syntax">#</a> Short struct literal syntax</h3>
{% set code = "struct Point {\n	x int\n	y int\n}\n\nmut p := Point{\n	x: 10\n	y: 20\n}\np = Point{\n	x: 30\n	y: 4\n}\nassert p.y == 4\n//\n// array: first element defines type of array\npoints := [Point{10, 20}, Point{20, 30}, Point{40, 50}]\nprintln(points) // [Point{x: 10, y: 20}, Point{x: 20, y: 30}, Point{x: 40,y: 50}]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Omitting the struct name also works for returning a struct literal or passing one
as a function argument.</p>
<h3 id="struct-update-syntax"><a class="markdownIt-Anchor" href="#struct-update-syntax">#</a> Struct update syntax</h3>
<p>V makes it easy to return a modified version of an object:</p>
{% set code = "struct User {\n	name          string\n	age           int\n	is_registered bool\n}\n\nfn register(u User) User {\n	return User{\n		...u\n		is_registered: true\n	}\n}\n\nmut user := User{\n	name: 'abc'\n	age: 23\n}\nuser = register(user)\nprintln(user)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="trailing-struct-literal-arguments"><a class="markdownIt-Anchor" href="#trailing-struct-literal-arguments">#</a> Trailing struct literal arguments</h3>
<p>V doesn't have default function arguments or named arguments, for that trailing struct
literal syntax can be used instead:</p>
{% set code = "[params]\nstruct ButtonConfig {\n	text        string\n	is_disabled bool\n	width       int = 70\n	height      int = 20\n}\n\nstruct Button {\n	text   string\n	width  int\n	height int\n}\n\nfn new_button(c ButtonConfig) &Button {\n	return &Button{\n		width: c.width\n		height: c.height\n		text: c.text\n	}\n}\n\nbutton := new_button(text: 'Click me', width: 100)\n// the height is unset, so it's the default value\nassert button.height == 20" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>As you can see, both the struct name and braces can be omitted, instead of:</p>
{% set code = "new_button(ButtonConfig{text:'Click me', width:100})" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This only works for functions that take a struct for the last argument.</p>
<blockquote>
<p>Note the <code>[params]</code> tag is used to tell V, that the trailing struct parameter
can be omitted <em>entirely</em>, so that you can write <code>button := new_button()</code>.
Without it, you have to specify <em>at least</em> one of the field names, even if it
has its default value, otherwise the compiler will produce this error message,
when you call the function with no parameters:
<code>error: expected 1 arguments, but got 0</code>.</p>
</blockquote>
<h3 id="access-modifiers"><a class="markdownIt-Anchor" href="#access-modifiers">#</a> Access modifiers</h3>
<p>Struct fields are private and immutable by default (making structs immutable as well).
Their access modifiers can be changed with
<code>pub</code> and <code>mut</code>. In total, there are 5 possible options:</p>
{% set code = "struct Foo {\n	a int // private immutable (default)\nmut:\n	b int // private mutable\n	c int // (you can list multiple fields with the same access modifier)\npub:\n	d int // public immutable (readonly)\npub mut:\n	e int // public, but mutable only in parent module\n__global:\n	// (not recommended to use, that's why the 'global' keyword starts with __)\n	f int // public and mutable both inside and outside parent module\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Private fields are available only inside the same <a href="#modules">module</a>, any attempt
to directly access them from another module will cause an error during compilation.
Public immutable fields are readonly everywhere.</p>
<h3 id="anonymous-structs"><a class="markdownIt-Anchor" href="#anonymous-structs">#</a> Anonymous structs</h3>
<p>V supports anonymous structs: structs that don't have to be declared separately
with a struct name.</p>
{% set code = "struct Book {\n	author struct {\n		name string\n		age  int\n	}\n\n	title string\n}\n\nbook := Book{\n	author: struct {\n		name: 'Samantha Black'\n		age: 24\n	}\n}\nassert book.author.name == 'Samantha Black'\nassert book.author.age == 24" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="noinit-structs"><a class="markdownIt-Anchor" href="#noinit-structs">#</a> <code>[noinit]</code> structs</h3>
<p>V supports <code>[noinit]</code> structs, which are structs that cannot be initialised outside the module
they are defined in. They are either meant to be used internally or they can be used externally
through <em>factory functions</em>.</p>
<p>For an example, consider the following source in a directory <code>sample</code>:</p>
{% set code = "module sample\n\n[noinit]\npub struct Information {\npub:\n	data string\n}\n\npub fn new_information(data string) !Information {\n	if data.len == 0 || data.len > 100 {\n		return error('data must be between 1 and 100 characters')\n	}\n	return Information{\n		data: data\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Note that <code>new_information</code> is a <em>factory</em> function. Now when we want to use this struct
outside the module:</p>
{% set code = "import sample\n\nfn main() {\n	// This doesn't work when the [noinit] attribute is present:\n	// info := sample.Information{\n	// 	data: 'Sample information.'\n	// }\n\n	// Use this instead:\n	info := sample.new_information('Sample information.')!\n\n	println(info)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="methods"><a class="markdownIt-Anchor" href="#methods">#</a> Methods</h3>
{% set code = "struct User {\n	age int\n}\n\nfn (u User) can_register() bool {\n	return u.age > 16\n}\n\nuser := User{\n	age: 10\n}\nprintln(user.can_register()) // \"false\"\nuser2 := User{\n	age: 20\n}\nprintln(user2.can_register()) // \"true\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V doesn't have classes, but you can define methods on types.
A method is a function with a special receiver argument.
The receiver appears in its own argument list between the <code>fn</code> keyword and the method name.
Methods must be in the same module as the receiver type.</p>
<p>In this example, the <code>can_register</code> method has a receiver of type <code>User</code> named <code>u</code>.
The convention is not to use receiver names like <code>self</code> or <code>this</code>,
but a short, preferably one letter long, name.</p>
<h3 id="embedded-structs"><a class="markdownIt-Anchor" href="#embedded-structs">#</a> Embedded structs</h3>
<p>V support embedded structs .</p>
{% set code = "struct Size {\nmut:\n	width  int\n	height int\n}\n\nfn (s &Size) area() int {\n	return s.width * s.height\n}\n\nstruct Button {\n	Size\n	title string\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>With embedding, the struct <code>Button</code> will automatically have get all the fields and methods from
the struct <code>Size</code>, which allows you to do:</p>
{% set code = "mut button := Button{\n	title: 'Click me'\n	height: 2\n}\n\nbutton.width = 3\nassert button.area() == 6\nassert button.Size.area() == 6\nprint(button)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>output :</p>
{% set code = "Button{\n    Size: Size{\n        width: 3\n        height: 2\n    }\n    title: 'Click me'\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Unlike inheritance, you cannot type cast between structs and embedded structs
(the embedding struct can also has its own fields, and it can also embed multiple structs).</p>
<p>If you need to access embedded structs directly, use an explicit reference like <code>button.Size</code>.</p>
<p>Conceptually, embedded structs are similar to <a href="https://en.wikipedia.org/wiki/Mixin">mixin</a>s
in OOP, <em>NOT</em> base classes.</p>
<p>You can also initialize an embedded struct:</p>
{% set code = "mut button := Button{\n	Size: Size{\n		width: 3\n		height: 2\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>or assign values:</p>
{% set code = "button.Size = Size{\n	width: 4\n	height: 5\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If multiple embedded structs have methods or fields with the same name, or if methods or fields
with the same name are defined in the struct, you can call methods or assign to variables in
the embedded struct like <code>button.Size.area()</code>.
When you do not specify the embedded struct name, the method of the outermost struct will be
targeted.</p>
<h2 id="unions"><a class="markdownIt-Anchor" href="#unions">#</a> Unions</h2>
<p>Just like structs, unions support embedding.</p>
{% set code = "struct Rgba32_Component {\n	r byte\n	g byte\n	b byte\n	a byte\n}\n\nunion Rgba32 {\n	Rgba32_Component\n	value u32\n}\n\nclr1 := Rgba32{\n	value: 0x008811FF\n}\n\nclr2 := Rgba32{\n	Rgba32_Component: Rgba32_Component{\n		a: 128\n	}\n}\n\nsz := sizeof(Rgba32)\nunsafe {\n	println('Size: ${sz}B,clr1.b: ${clr1.b},clr2.b: ${clr2.b}')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Output: <code>Size: 4B, clr1.b: 136, clr2.b: 0</code></p>
<p>Union member access must be performed in an <code>unsafe</code> block.</p>
<blockquote>
<p><strong>Note</strong>
Embedded struct arguments are not necessarily stored in the order listed.</p>
</blockquote>
<h2 id="functions-2"><a class="markdownIt-Anchor" href="#functions-2">#</a> Functions 2</h2>
<h3 id="immutable-function-args-by-default"><a class="markdownIt-Anchor" href="#immutable-function-args-by-default">#</a> Immutable function args by default</h3>
<p>In V function arguments are immutable by default, and mutable args have to be
marked on call.</p>
<p>Since there are also no globals, that means that the return values of the functions,
are a function of their arguments only, and their evaluation has no side effects
(unless the function uses I/O).</p>
<p>Function arguments are immutable by default, even when <a href="#references">references</a> are passed.</p>
<blockquote>
<p><strong>Note</strong>
V is not a purely functional language however.</p>
</blockquote>
<p>There is a compiler flag to enable global variables (<code>-enable-globals</code>), but this is
intended for low-level applications like kernels and drivers.</p>
<h3 id="mutable-arguments"><a class="markdownIt-Anchor" href="#mutable-arguments">#</a> Mutable arguments</h3>
<p>It is possible to modify function arguments by declaring them with the keyword <code>mut</code>:</p>
{% set code = "struct User {\n	name string\nmut:\n	is_registered bool\n}\n\nfn (mut u User) register() {\n	u.is_registered = true\n}\n\nmut user := User{}\nprintln(user.is_registered) // \"false\"\nuser.register()\nprintln(user.is_registered) // \"true\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>In this example, the receiver (which is just the first argument) is explicitly marked as mutable,
so <code>register()</code> can change the user object. The same works with non-receiver arguments:</p>
{% set code = "fn multiply_by_2(mut arr []int) {\n	for i in 0 .. arr.len {\n		arr[i] *= 2\n	}\n}\n\nmut nums := [1, 2, 3]\nmultiply_by_2(mut nums)\nprintln(nums)\n// \"[2, 4, 6]\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Note, that you have to add <code>mut</code> before <code>nums</code> when calling this function. This makes
it clear that the function being called will modify the value.</p>
<p>It is preferable to return values instead of modifying arguments,
e.g. <code>user = register(user)</code> (or <code>user.register()</code>) instead of <code>register(mut user)</code>.
Modifying arguments should only be done in performance-critical parts of your application
to reduce allocations and copying.</p>
<p>For this reason V doesn't allow the modification of arguments with primitive types (e.g. integers).
Only more complex types such as arrays and maps may be modified.</p>
<h3 id="variable-number-of-arguments"><a class="markdownIt-Anchor" href="#variable-number-of-arguments">#</a> Variable number of arguments</h3>
{% set code = "fn sum(a ...int) int {\n	mut total := 0\n	for x in a {\n		total += x\n	}\n	return total\n}\n\nprintln(sum()) // 0\nprintln(sum(1)) // 1\nprintln(sum(2, 3)) // 5\n// using array decomposition\na := [2, 3, 4]\nprintln(sum(...a)) // <-- using prefix ... here. output: 9\nb := [5, 6, 7]\nprintln(sum(...b)) // output: 18" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="anonymous-higher-order-functions"><a class="markdownIt-Anchor" href="#anonymous-higher-order-functions">#</a> Anonymous &amp; higher order functions</h3>
{% set code = "fn sqr(n int) int {\n	return n * n\n}\n\nfn cube(n int) int {\n	return n * n * n\n}\n\nfn run(value int, op fn (int) int) int {\n	return op(value)\n}\n\nfn main() {\n	// Functions can be passed to other functions\n	println(run(5, sqr)) // \"25\"\n	// Anonymous functions can be declared inside other functions:\n	double_fn := fn (n int) int {\n		return n + n\n	}\n	println(run(5, double_fn)) // \"10\"\n	// Functions can be passed around without assigning them to variables:\n	res := run(5, fn (n int) int {\n		return n + n\n	})\n	println(res) // \"10\"\n	// You can even have an array/map of functions:\n	fns := [sqr, cube]\n	println(fns[0](10)) // \"100\"\n	fns_map := {\n		'sqr':  sqr\n		'cube': cube\n	}\n	println(fns_map['cube'](2)) // \"8\"\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="closures"><a class="markdownIt-Anchor" href="#closures">#</a> Closures</h3>
<p>V supports closures too.
This means that anonymous functions can inherit variables from the scope they were created in.
They must do so explicitly by listing all variables that are inherited.</p>
{% set code = "my_int := 1\nmy_closure := fn [my_int] () {\n	println(my_int)\n}\nmy_closure() // prints 1" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Inherited variables are copied when the anonymous function is created.
This means that if the original variable is modified after the creation of the function,
the modification won't be reflected in the function.</p>
{% set code = "mut i := 1\nfunc := fn [i] () int {\n	return i\n}\nprintln(func() == 1) // true\ni = 123\nprintln(func() == 1) // still true" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>However, the variable can be modified inside the anonymous function.
The change won't be reflected outside, but will be in the later function calls.</p>
{% set code = "fn new_counter() fn () int {\n	mut i := 0\n	return fn [mut i] () int {\n		i++\n		return i\n	}\n}\n\nc := new_counter()\nprintln(c()) // 1\nprintln(c()) // 2\nprintln(c()) // 3" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If you need the value to be modified outside the function, use a reference.
<strong>Warning</strong>: <em>you need to make sure the reference is always valid,
otherwise this can result in undefined behavior.</em></p>
{% set code = "mut i := 0\nmut ref := &i\nprint_counter := fn [ref] () {\n	println(*ref)\n}\n\nprint_counter() // 0\ni = 10\nprint_counter() // 10" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="parameter-evaluation-order"><a class="markdownIt-Anchor" href="#parameter-evaluation-order">#</a> Parameter evaluation order</h3>
<p>The evaluation order of the parameters of function calls is <em>NOT</em> guaranteed.
Take for example the following program:</p>
{% set code = "fn f(a1 int, a2 int, a3 int) {\n	dump(a1 + a2 + a3)\n}\n\nfn main() {\n	f(dump(100), dump(200), dump(300))\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V currently does not guarantee, that it will print 100, 200, 300 in that order.
The only guarantee is that 600 (from the body of <code>f</code>), will be printed after all of them.
That <em>may</em> change in V 1.0 .</p>
<h2 id="references"><a class="markdownIt-Anchor" href="#references">#</a> References</h2>
{% set code = "struct Foo {}\n\nfn (foo Foo) bar_method() {\n	// ...\n}\n\nfn bar_function(foo Foo) {\n	// ...\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If a function argument is immutable (like <code>foo</code> in the examples above)
V can pass it either by value or by reference. The compiler will decide,
and the developer doesn't need to think about it.</p>
<p>You no longer need to remember whether you should pass the struct by value
or by reference.</p>
<p>You can ensure that the struct is always passed by reference by
adding <code>&amp;</code>:</p>
{% set code = "struct Foo {\n	abc int\n}\n\nfn (foo &Foo) bar() {\n	println(foo.abc)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>foo</code> is still immutable and can't be changed. For that,
<code>(mut foo Foo)</code> must be used.</p>
<p>In general, V's references are similar to Go pointers and C++ references.
For example, a generic tree structure definition would look like this:</p>
{% set code = "struct Node[T] {\n	val   T\n	left  &Node[T]\n	right &Node[T]\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>To dereference a reference, use the <code>*</code> operator, just like in C.</p>
<h2 id="constants"><a class="markdownIt-Anchor" href="#constants">#</a> Constants</h2>
{% set code = "const (\n	pi    = 3.14\n	world = '‰∏ñÁïå'\n)\n\nprintln(pi)\nprintln(world)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Constants are declared with <code>const</code>. They can only be defined
at the module level (outside of functions).
Constant values can never be changed. You can also declare a single
constant separately:</p>
{% set code = "const e = 2.71828" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V constants are more flexible than in most languages. You can assign more complex values:</p>
{% set code = "struct Color {\n	r int\n	g int\n	b int\n}\n\nfn rgb(r int, g int, b int) Color {\n	return Color{\n		r: r\n		g: g\n		b: b\n	}\n}\n\nconst (\n	numbers = [1, 2, 3]\n	red     = Color{\n		r: 255\n		g: 0\n		b: 0\n	}\n	// evaluate function call at compile-time*\n	blue = rgb(0, 0, 255)\n)\n\nprintln(numbers)\nprintln(red)\nprintln(blue)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>* WIP - for now function calls are evaluated at program start-up</p>
<p>Global variables are not normally allowed, so this can be really useful.</p>
<p><strong>Modules</strong></p>
<p>Constants can be made public with <code>pub const</code>:</p>
{% set code = "module mymodule\n\npub const golden_ratio = 1.61803\n\nfn calc() {\n	println(mymodule.golden_ratio)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The <code>pub</code> keyword is only allowed before the <code>const</code> keyword and cannot be used inside
a <code>const ( )</code> block.</p>
<p>Outside from module main all constants need to be prefixed with the module name.</p>
<h3 id="required-module-prefix"><a class="markdownIt-Anchor" href="#required-module-prefix">#</a> Required module prefix</h3>
<p>When naming constants, <code>snake_case</code> must be used. In order to distinguish consts
from local variables, the full path to consts must be specified. For example,
to access the PI const, full <code>math.pi</code> name must be used both outside the <code>math</code>
module, and inside it. That restriction is relaxed only for the <code>main</code> module
(the one containing your <code>fn main()</code>), where you can use the unqualified name of
constants defined there, i.e. <code>numbers</code>, rather than <code>main.numbers</code>.</p>
<p>vfmt takes care of this rule, so you can type <code>println(pi)</code> inside the <code>math</code> module,
and vfmt will automatically update it to <code>println(math.pi)</code>.</p>
<p>&lt;!--
Many people prefer all caps consts: <code>TOP_CITIES</code>. This wouldn't work
well in V, because consts are a lot more powerful than in other languages.
They can represent complex structures, and this is used quite often since there
are no globals:</p>
{% set code = "println('Top cities: ${top_cities.filter(.usa)}')" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>--&gt;</p>
<h2 id="builtin-functions"><a class="markdownIt-Anchor" href="#builtin-functions">#</a> Builtin functions</h2>
<p>Some functions are builtin like <code>println</code>. Here is the complete list:</p>
{% set code = "fn print(s string) // prints anything on stdout\nfn println(s string) // prints anything and a newline on stdout\n\nfn eprint(s string) // same as print(), but uses stderr\nfn eprintln(s string) // same as println(), but uses stderr\n\nfn exit(code int) // terminates the program with a custom error code\nfn panic(s string) // prints a message and backtraces on stderr, and terminates the program with error code 1\nfn print_backtrace() // prints backtraces on stderr" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
Although the <code>print</code> functions take a string, V accepts other printable types too.
See below for details.</p>
</blockquote>
<p>There is also a special built-in function called <a href="#dumping-expressions-at-runtime"><code>dump</code></a>.</p>
<h3 id="println"><a class="markdownIt-Anchor" href="#println">#</a> println</h3>
<p><code>println</code> is a simple yet powerful builtin function, that can print anything:
strings, numbers, arrays, maps, structs.</p>
{% set code = "struct User {\n	name string\n	age  int\n}\n\nprintln(1) // \"1\"\nprintln('hi') // \"hi\"\nprintln([1, 2, 3]) // \"[1, 2, 3]\"\nprintln(User{ name: 'Bob', age: 20 }) // \"User{name:'Bob', age:20}\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>See also <a href="#array-methods">Array methods</a>.</p>
<p>&lt;a id='custom-print-of-types'&gt;&lt;/a&gt;</p>
<h3 id="printing-custom-types"><a class="markdownIt-Anchor" href="#printing-custom-types">#</a> Printing custom types</h3>
<p>If you want to define a custom print value for your type, simply define a
<code>str() string</code> method:</p>
{% set code = "struct Color {\n	r int\n	g int\n	b int\n}\n\npub fn (c Color) str() string {\n	return '{${c.r}, ${c.g}, ${c.b}}'\n}\n\nred := Color{\n	r: 255\n	g: 0\n	b: 0\n}\nprintln(red)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="dumping-expressions-at-runtime"><a class="markdownIt-Anchor" href="#dumping-expressions-at-runtime">#</a> Dumping expressions at runtime</h3>
<p>You can dump/trace the value of any V expression using <code>dump(expr)</code>.
For example, save this code sample as <code>factorial.v</code>, then run it with
<code>v run factorial.v</code>:</p>
{% set code = "fn factorial(n u32) u32 {\n	if dump(n <= 1) {\n		return dump(1)\n	}\n	return dump(n * factorial(n - 1))\n}\n\nfn main() {\n	println(factorial(5))\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You will get:</p>
{% set code = "[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: false\n[factorial.v:2] n <= 1: true\n[factorial.v:3] 1: 1\n[factorial.v:5] n * factorial(n - 1): 2\n[factorial.v:5] n * factorial(n - 1): 6\n[factorial.v:5] n * factorial(n - 1): 24\n[factorial.v:5] n * factorial(n - 1): 120\n120" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Note that <code>dump(expr)</code> will trace both the source location,
the expression itself, and the expression value.</p>
<h2 id="modules"><a class="markdownIt-Anchor" href="#modules">#</a> Modules</h2>
<p>Every file in the root of a folder is part of the same module.
Simple programs don't need to specify module name, in which case it defaults to 'main'.</p>
<p>See <a href="#symbol-visibility">symbol visibility</a>, <a href="#access-modifiers">Access modifiers</a>.</p>
<h3 id="create-modules"><a class="markdownIt-Anchor" href="#create-modules">#</a> Create modules</h3>
<p>V is a very modular language. Creating reusable modules is encouraged and is
quite easy to do.
To create a new module, create a directory with your module's name containing
.v files with code:</p>
{% set code = "cd ~/code/modules\nmkdir mymodule\nvim mymodule/myfile.v" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "// myfile.v\nmodule mymodule\n\n// To export a function we have to use `pub`\npub fn say_hi() {\n	println('hello from mymodule!')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can now use <code>mymodule</code> in your code:</p>
{% set code = "import mymodule\n\nfn main() {\n	mymodule.say_hi()\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<ul>
<li>Module names should be short, under 10 characters.</li>
<li>Module names must use <code>snake_case</code>.</li>
<li>Circular imports are not allowed.</li>
<li>You can have as many .v files in a module as you want.</li>
<li>You can create modules anywhere.</li>
<li>All modules are compiled statically into a single executable.</li>
</ul>
<h3 id="init-functions"><a class="markdownIt-Anchor" href="#init-functions">#</a> <code>init</code> functions</h3>
<p>If you want a module to automatically call some setup/initialization code when it is imported,
you can use a module <code>init</code> function:</p>
{% set code = "fn init() {\n	// your setup code here ...\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The <code>init</code> function cannot be public - it will be called automatically. This feature is
particularly useful for initializing a C library.</p>
<h2 id="type-declarations"><a class="markdownIt-Anchor" href="#type-declarations">#</a> Type Declarations</h2>
<h3 id="type-aliases"><a class="markdownIt-Anchor" href="#type-aliases">#</a> Type aliases</h3>
<p>To define a new type <code>NewType</code> as an alias for <code>ExistingType</code>,
do <code>type NewType = ExistingType</code>.&lt;br/&gt;
This is a special case of a <a href="#sum-types">sum type</a> declaration.</p>
<h3 id="enums"><a class="markdownIt-Anchor" href="#enums">#</a> Enums</h3>
{% set code = "enum Color as u8 {\n	red\n	green\n	blue\n}\n\nmut color := Color.red\n// V knows that `color` is a `Color`. No need to use `color = Color.green` here.\ncolor = .green\nprintln(color) // \"green\"\nmatch color {\n	.red { println('the color was red') }\n	.green { println('the color was green') }\n	.blue { println('the color was blue') }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The enum type can be any integer type, but can be omitted, if it is <code>int</code>: <code>enum Color {</code>.</p>
<p>Enum match must be exhaustive or have an <code>else</code> branch.
This ensures that if a new enum field is added, it's handled everywhere in the code.</p>
<p>Enum fields cannot re-use reserved keywords. However, reserved keywords may be escaped
with an @.</p>
{% set code = "enum Color {\n	@none\n	red\n	green\n	blue\n}\n\ncolor := Color.@none\nprintln(color)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Integers may be assigned to enum fields.</p>
{% set code = "enum Grocery {\n	apple\n	orange = 5\n	pear\n}\n\ng1 := int(Grocery.apple)\ng2 := int(Grocery.orange)\ng3 := int(Grocery.pear)\nprintln('Grocery IDs: ${g1}, ${g2}, ${g3}')" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Output: <code>Grocery IDs: 0, 5, 6</code>.</p>
<p>Operations are not allowed on enum variables; they must be explicitly cast to <code>int</code>.</p>
<p>Enums can have methods, just like structs.</p>
{% set code = "enum Cycle {\n	one\n	two\n	three\n}\n\nfn (c Cycle) next() Cycle {\n	match c {\n		.one {\n			return .two\n		}\n		.two {\n			return .three\n		}\n		.three {\n			return .one\n		}\n	}\n}\n\nmut c := Cycle.one\nfor _ in 0 .. 10 {\n	println(c)\n	c = c.next()\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Output:</p>
{% set code = "one\ntwo\nthree\none\ntwo\nthree\none\ntwo\nthree\none" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="function-types"><a class="markdownIt-Anchor" href="#function-types">#</a> Function Types</h3>
<p>You can use type aliases for naming specific function signatures - for
example:</p>
{% set code = "type Filter = fn (string) string" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This works like any other type - for example, a function can accept an
argument of a function type:</p>
{% set code = "type Filter = fn (string) string\n\nfn filter(s string, f Filter) string {\n	return f(s)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V has duck-typing, so functions don't need to declare compatibility with
a function type - they just have to be compatible:</p>
{% set code = "fn uppercase(s string) string {\n	return s.to_upper()\n}\n\n// now `uppercase` can be used everywhere where Filter is expected" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Compatible functions can also be explicitly cast to a function type:</p>
{% set code = "my_filter := Filter(uppercase)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The cast here is purely informational - again, duck-typing means that the
resulting type is the same without an explicit cast:</p>
{% set code = "my_filter := uppercase" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can pass the assigned function as an argument:</p>
{% set code = "println(filter('Hello world', my_filter)) // prints `HELLO WORLD`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>And you could of course have passed it directly as well, without using a
local variable:</p>
{% set code = "println(filter('Hello world', uppercase))" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>And this works with anonymous functions as well:</p>
{% set code = "println(filter('Hello world', fn (s string) string {\n	return s.to_upper()\n}))" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can see the complete
<a href="https://github.com/vlang/v/tree/master/examples/function_types.v">example here</a>.</p>
<h3 id="interfaces"><a class="markdownIt-Anchor" href="#interfaces">#</a> Interfaces</h3>
{% set code = "// interface-example.1\nstruct Dog {\n	breed string\n}\n\nfn (d Dog) speak() string {\n	return 'woof'\n}\n\nstruct Cat {\n	breed string\n}\n\nfn (c Cat) speak() string {\n	return 'meow'\n}\n\n// unlike Go and like TypeScript, V's interfaces can define fields, not just methods.\ninterface Speaker {\n	breed string\n	speak() string\n}\n\nfn main() {\n	dog := Dog{'Leonberger'}\n	cat := Cat{'Siamese'}\n\n	mut arr := []Speaker{}\n	arr << dog\n	arr << cat\n	for item in arr {\n		println('a ${item.breed} says: ${item.speak()}')\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="implement-an-interface"><a class="markdownIt-Anchor" href="#implement-an-interface">#</a> Implement an interface</h4>
<p>A type implements an interface by implementing its methods and fields.
There is no explicit declaration of intent, no &quot;implements&quot; keyword.</p>
<p>An interface can have a <code>mut:</code> section. Implementing types will need
to have a <code>mut</code> receiver, for methods declared in the <code>mut:</code> section
of an interface.</p>
{% set code = "// interface-example.2\nmodule main\n\ninterface Foo {\n	write(string) string\n}\n\n// => the method signature of a type, implementing interface Foo should be:\n// `fn (s Type) write(a string) string`\n\ninterface Bar {\nmut:\n	write(string) string\n}\n\n// => the method signature of a type, implementing interface Bar should be:\n// `fn (mut s Type) write(a string) string`\n\nstruct MyStruct {}\n\n// MyStruct implements the interface Foo, but *not* interface Bar\nfn (s MyStruct) write(a string) string {\n	return a\n}\n\nfn main() {\n	s1 := MyStruct{}\n	fn1(s1)\n	// fn2(s1) -> compile error, since MyStruct does not implement Bar\n}\n\nfn fn1(s Foo) {\n	println(s.write('Foo'))\n}\n\n// fn fn2(s Bar) { // does not match\n//      println(s.write('Foo'))\n// }" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="casting-an-interface"><a class="markdownIt-Anchor" href="#casting-an-interface">#</a> Casting an interface</h4>
<p>We can test the underlying type of an interface using dynamic cast operators:</p>
{% set code = "// interface-exmaple.3 (continued from interface-exampe.1)\ninterface Something {}\n\nfn announce(s Something) {\n	if s is Dog {\n		println('a ${s.breed} dog') // `s` is automatically cast to `Dog` (smart cast)\n	} else if s is Cat {\n		println('a cat speaks ${s.speak()}')\n	} else {\n		println('something else')\n	}\n}\n\nfn main() {\n	dog := Dog{'Leonberger'}\n	cat := Cat{'Siamese'}\n	announce(dog)\n	announce(cat)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "// interface-example.4\ninterface IFoo {\n	foo()\n}\n\ninterface IBar {\n	bar()\n}\n\n// implements only IFoo\nstruct SFoo {}\n\nfn (sf SFoo) foo() {}\n\n// implements both IFoo and IBar\nstruct SFooBar {}\n\nfn (sfb SFooBar) foo() {}\n\nfn (sfb SFooBar) bar() {\n	dump('This implements IBar')\n}\n\nfn main() {\n	mut arr := []IFoo{}\n	arr << SFoo{}\n	arr << SFooBar{}\n\n	for a in arr {\n		dump(a)\n		// In order to execute instances that implements IBar.\n		if a is IBar {\n			// a.bar() // Error.\n			b := a as IBar\n			dump(b)\n			b.bar()\n		}\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>For more information, see <a href="#dynamic-casts">Dynamic casts</a>.</p>
<h4 id="interface-method-definitions"><a class="markdownIt-Anchor" href="#interface-method-definitions">#</a> Interface method definitions</h4>
<p>Also unlike Go, an interface can have it's own methods, similar to how
structs can have their methods. These 'interface methods' do not have
to be implemented, by structs which implement that interface.
They are just a convenient way to write <code>i.some_function()</code> instead of
<code>some_function(i)</code>, similar to how struct methods can be looked at, as
a convenience for writing <code>s.xyz()</code> instead of <code>xyz(s)</code>.</p>
<blockquote>
<p><strong>Note</strong>
This feature is NOT a &quot;default implementation&quot; like in C#.</p>
</blockquote>
<p>For example, if a struct <code>cat</code> is wrapped in an interface <code>a</code>, that has
implemented a method with the same name <code>speak</code>, as a method implemented by
the struct, and you do <code>a.speak()</code>, <em>only</em> the interface method is called:</p>
{% set code = "interface Adoptable {}\n\nfn (a Adoptable) speak() string {\n	return 'adopt me!'\n}\n\nstruct Cat {}\n\nfn (c Cat) speak() string {\n	return 'meow!'\n}\n\nstruct Dog {}\n\nfn main() {\n	cat := Cat{}\n	assert dump(cat.speak()) == 'meow!'\n	//\n	a := Adoptable(cat)\n	assert dump(a.speak()) == 'adopt me!' // call Adoptable's `speak`\n	if a is Cat {\n		// Inside this `if` however, V knows that `a` is not just any\n		// kind of Adoptable, but actually a Cat, so it will use the\n		// Cat `speak`, NOT the Adoptable `speak`:\n		dump(a.speak()) // meow!\n	}\n	//\n	b := Adoptable(Dog{})\n	assert dump(b.speak()) == 'adopt me!' // call Adoptable's `speak`\n	// if b is Dog {\n	// 	dump(b.speak()) // error: unknown method or field: Dog.speak\n	// }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="embedded-interface"><a class="markdownIt-Anchor" href="#embedded-interface">#</a> Embedded interface</h4>
<p>Interfaces support embedding, just like structs:</p>
{% set code = "pub interface Reader {\nmut:\n	read(mut buf []byte) ?int\n}\n\npub interface Writer {\nmut:\n	write(buf []byte) ?int\n}\n\n// ReaderWriter embeds both Reader and Writer.\n// The effect is the same as copy/pasting all of the\n// Reader and all of the Writer methods/fields into\n// ReaderWriter.\npub interface ReaderWriter {\n	Reader\n	Writer\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="sum-types"><a class="markdownIt-Anchor" href="#sum-types">#</a> Sum types</h3>
<p>A sum type instance can hold a value of several different types. Use the <code>type</code>
keyword to declare a sum type:</p>
{% set code = "struct Moon {}\n\nstruct Mars {}\n\nstruct Venus {}\n\ntype World = Mars | Moon | Venus\n\nsum := World(Moon{})\nassert sum.type_name() == 'Moon'\nprintln(sum)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The built-in method <code>type_name</code> returns the name of the currently held
type.</p>
<p>With sum types you could build recursive structures and write concise but powerful code on them.</p>
{% set code = "// V's binary tree\nstruct Empty {}\n\nstruct Node {\n	value f64\n	left  Tree\n	right Tree\n}\n\ntype Tree = Empty | Node\n\n// sum up all node values\n\nfn sum(tree Tree) f64 {\n	return match tree {\n		Empty { 0 }\n		Node { tree.value + sum(tree.left) + sum(tree.right) }\n	}\n}\n\nfn main() {\n	left := Node{0.2, Empty{}, Empty{}}\n	right := Node{0.3, Empty{}, Node{0.4, Empty{}, Empty{}}}\n	tree := Node{0.5, left, right}\n	println(sum(tree)) // 0.2 + 0.3 + 0.4 + 0.5 = 1.4\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="dynamic-casts"><a class="markdownIt-Anchor" href="#dynamic-casts">#</a> Dynamic casts</h4>
<p>To check whether a sum type instance holds a certain type, use <code>sum is Type</code>.
To cast a sum type to one of its variants you can use <code>sum as Type</code>:</p>
{% set code = "struct Moon {}\n\nstruct Mars {}\n\nstruct Venus {}\n\ntype World = Mars | Moon | Venus\n\nfn (m Mars) dust_storm() bool {\n	return true\n}\n\nfn main() {\n	mut w := World(Moon{})\n	assert w is Moon\n	w = Mars{}\n	// use `as` to access the Mars instance\n	mars := w as Mars\n	if mars.dust_storm() {\n		println('bad weather!')\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>as</code> will panic if <code>w</code> doesn't hold a <code>Mars</code> instance.
A safer way is to use a smart cast.</p>
<h4 id="smart-casting"><a class="markdownIt-Anchor" href="#smart-casting">#</a> Smart casting</h4>
{% set code = "if w is Mars {\n	assert typeof(w).name == 'Mars'\n	if w.dust_storm() {\n		println('bad weather!')\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>w</code> has type <code>Mars</code> inside the body of the <code>if</code> statement. This is
known as <em>flow-sensitive typing</em>.
If <code>w</code> is a mutable identifier, it would be unsafe if the compiler smart casts it without a warning.
That's why you have to declare a <code>mut</code> before the <code>is</code> expression:</p>
{% set code = "if mut w is Mars {\n	assert typeof(w).name == 'Mars'\n	if w.dust_storm() {\n		println('bad weather!')\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Otherwise <code>w</code> would keep its original type.</p>
<blockquote>
<p>This works for both, simple variables and complex expressions like <code>user.name</code></p>
</blockquote>
<h4 id="matching-sum-types"><a class="markdownIt-Anchor" href="#matching-sum-types">#</a> Matching sum types</h4>
<p>You can also use <code>match</code> to determine the variant:</p>
{% set code = "struct Moon {}\n\nstruct Mars {}\n\nstruct Venus {}\n\ntype World = Mars | Moon | Venus\n\nfn open_parachutes(n int) {\n	println(n)\n}\n\nfn land(w World) {\n	match w {\n		Moon {} // no atmosphere\n		Mars {\n			// light atmosphere\n			open_parachutes(3)\n		}\n		Venus {\n			// heavy atmosphere\n			open_parachutes(1)\n		}\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>match</code> must have a pattern for each variant or have an <code>else</code> branch.</p>
{% set code = "struct Moon {}\nstruct Mars {}\nstruct Venus {}\n\ntype World = Moon | Mars | Venus\n\nfn (m Moon) moon_walk() {}\nfn (m Mars) shiver() {}\nfn (v Venus) sweat() {}\n\nfn pass_time(w World) {\n    match w {\n        // using the shadowed match variable, in this case `w` (smart cast)\n        Moon { w.moon_walk() }\n        Mars { w.shiver() }\n        else {}\n    }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="optionresult-types-and-error-handling"><a class="markdownIt-Anchor" href="#optionresult-types-and-error-handling">#</a> Option/Result types and error handling</h3>
<p>Option types are for types which may represent <code>none</code>. Result types may
represent an error returned from a function.</p>
<p><code>Option</code> types are declared by prepending <code>?</code> to the type name: <code>?Type</code>.
<code>Result</code> types use <code>!</code>: <code>!Type</code>.</p>
{% set code = "struct User {\n	id   int\n	name string\n}\n\nstruct Repo {\n	users []User\n}\n\nfn (r Repo) find_user_by_id(id int) !User {\n	for user in r.users {\n		if user.id == id {\n			// V automatically wraps this into a result or option type\n			return user\n		}\n	}\n	return error('User ${id} not found')\n}\n\n// A version of the function using an option\nfn (r Repo) find_user_by_id2(id int) ?User {\n	for user in r.users {\n		if user.id == id {\n			return user\n		}\n	}\n	return none\n}\n\nfn main() {\n	repo := Repo{\n		users: [User{1, 'Andrew'}, User{2, 'Bob'}, User{10, 'Charles'}]\n	}\n	user := repo.find_user_by_id(10) or { // Option/Result types must be handled by `or` blocks\n		println(err)\n		return\n	}\n	println(user.id) // \"10\"\n	println(user.name) // \"Charles\"\n\n	user2 := repo.find_user_by_id2(10) or { return }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V used to combine <code>Option</code> and <code>Result</code> into one type, now they are separate.</p>
<p>The amount of work required to &quot;upgrade&quot; a function to an option/result function is minimal;
you have to add a <code>?</code> or <code>!</code> to the return type and return an error when something goes wrong.</p>
<p>This is the primary mechanism for error handling in V. They are still values, like in Go,
but the advantage is that errors can't be unhandled, and handling them is a lot less verbose.
Unlike other languages, V does not handle exceptions with <code>throw/try/catch</code> blocks.</p>
<p><code>err</code> is defined inside an <code>or</code> block and is set to the string message passed
to the <code>error()</code> function.</p>
{% set code = "user := repo.find_user_by_id(7) or {\n	println(err) // \"User 7 not found\"\n	return\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="handling-optionsresults"><a class="markdownIt-Anchor" href="#handling-optionsresults">#</a> Handling options/results</h4>
<p>There are four ways of handling an option/result. The first method is to
propagate the error:</p>
{% set code = "import net.http\n\nfn f(url string) !string {\n	resp := http.get(url)!\n	return resp.body\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>http.get</code> returns <code>!http.Response</code>. Because <code>!</code> follows the call, the
error will be propagated to the caller of <code>f</code>. When using <code>?</code> after a
function call producing an option, the enclosing function must return
an option as well. If error propagation is used in the <code>main()</code>
function it will <code>panic</code> instead, since the error cannot be propagated
any further.</p>
<p>The body of <code>f</code> is essentially a condensed version of:</p>
{% set code = "    resp := http.get(url) or { return err }\n    return resp.body" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<hr>
<p>The second method is to break from execution early:</p>
{% set code = "user := repo.find_user_by_id(7) or { return }" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Here, you can either call <code>panic()</code> or <code>exit()</code>, which will stop the execution of the
entire program, or use a control flow statement (<code>return</code>, <code>break</code>, <code>continue</code>, etc)
to break from the current block.</p>
<blockquote>
<p><strong>Note</strong>
<code>break</code> and <code>continue</code> can only be used inside a <code>for</code> loop.</p>
</blockquote>
<p>V does not have a way to forcibly &quot;unwrap&quot; an option (as other languages do,
for instance Rust's <code>unwrap()</code> or Swift's <code>!</code>). To do this, use <code>or { panic(err) }</code> instead.</p>
<hr>
<p>The third method is to provide a default value at the end of the <code>or</code> block.
In case of an error, that value would be assigned instead,
so it must have the same type as the content of the <code>Option</code> being handled.</p>
{% set code = "fn do_something(s string) !string {\n	if s == 'foo' {\n		return 'foo'\n	}\n	return error('invalid string')\n}\n\na := do_something('foo') or { 'default' } // a will be 'foo'\nb := do_something('bar') or { 'default' } // b will be 'default'\nprintln(a)\nprintln(b)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<hr>
<p>The fourth method is to use <code>if</code> unwrapping:</p>
{% set code = "import net.http\n\nif resp := http.get('https://google.com') {\n	println(resp.body) // resp is a http.Response, not an option\n} else {\n	println(err)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Above, <code>http.get</code> returns a <code>!http.Response</code>. <code>resp</code> is only in scope for the first
<code>if</code> branch. <code>err</code> is only in scope for the <code>else</code> branch.</p>
<h3 id="custom-error-types"><a class="markdownIt-Anchor" href="#custom-error-types">#</a> Custom error types</h3>
<p>V gives you the ability to define custom error types through the <code>IError</code> interface.
The interface requires two methods: <code>msg() string</code> and <code>code() int</code>. Every type that
implements these methods can be used as an error.</p>
<p>When defining a custom error type it is recommended to embed the builtin <code>Error</code> default
implementation. This provides an empty default implementation for both required methods,
so you only have to implement what you really need, and may provide additional utility
functions in the future.</p>
{% set code = "struct PathError {\n	Error\n	path string\n}\n\nfn (err PathError) msg() string {\n	return 'Failed to open path: ${err.path}'\n}\n\nfn try_open(path string) ? {\n	return IError(PathError{\n		path: path\n	})\n}\n\nfn main() {\n	try_open('/tmp') or { panic(err) }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="generics"><a class="markdownIt-Anchor" href="#generics">#</a> Generics</h3>
{% set code = "\nstruct Repo[T] {\n    db DB\n}\n\nstruct User {\n	id   int\n	name string\n}\n\nstruct Post {\n	id   int\n	user_id int\n	title string\n	body string\n}\n\nfn new_repo[T](db DB) Repo[T] {\n    return Repo[T]{db: db}\n}\n\n// This is a generic function. V will generate it for every type it's used with.\nfn (r Repo[T]) find_by_id(id int) ?T {\n    table_name := T.name // in this example getting the name of the type gives us the table name\n    return r.db.query_one[T]('select * from ${table_name} where id = ?', id)\n}\n\ndb := new_db()\nusers_repo := new_repo[User](db) // returns Repo[User]\nposts_repo := new_repo[Post](db) // returns Repo[Post]\nuser := users_repo.find_by_id(1)? // find_by_id[User]\npost := posts_repo.find_by_id(1)? // find_by_id[Post]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Currently generic function definitions must declare their type parameters, but in
future V will infer generic type parameters from single-letter type names in
runtime parameter types. This is why <code>find_by_id</code> can omit <code>[T]</code>, because the
receiver argument <code>r</code> uses a generic type <code>T</code>.</p>
<p>Another example:</p>
{% set code = "fn compare[T](a T, b T) int {\n	if a < b {\n		return -1\n	}\n	if a > b {\n		return 1\n	}\n	return 0\n}\n\n// compare[int]\nprintln(compare(1, 0)) // Outputs: 1\nprintln(compare(1, 1)) //          0\nprintln(compare(1, 2)) //         -1\n// compare[string]\nprintln(compare('1', '0')) // Outputs: 1\nprintln(compare('1', '1')) //          0\nprintln(compare('1', '2')) //         -1\n// compare[f64]\nprintln(compare(1.1, 1.0)) // Outputs: 1\nprintln(compare(1.1, 1.1)) //          0\nprintln(compare(1.1, 1.2)) //         -1" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="concurrency"><a class="markdownIt-Anchor" href="#concurrency">#</a> Concurrency</h2>
<h3 id="spawning-concurrent-tasks"><a class="markdownIt-Anchor" href="#spawning-concurrent-tasks">#</a> Spawning Concurrent Tasks</h3>
<p>V's model of concurrency is going to be very similar to Go's.
For now, <code>spawn foo()</code> runs <code>foo()</code> concurrently in a different thread:</p>
{% set code = "import math\n\nfn p(a f64, b f64) { // ordinary function without return value\n	c := math.sqrt(a * a + b * b)\n	println(c)\n}\n\nfn main() {\n	spawn p(3, 4)\n	// p will be run in parallel thread\n	// It can also be written as follows\n	// spawn fn (a f64, b f64) {\n	// 	c := math.sqrt(a * a + b * b)\n	// 	println(c)\n	// }(3, 4)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>There's also a <code>go</code> keyword. Right now <code>go foo()</code> will be automatically renamed via vfmt
to <code>spawn foo()</code>, and there will be a way to launch a coroutine with <code>go</code> (a lightweight
thread managed by the runtime).</p>
<p>Sometimes it is necessary to wait until a parallel thread has finished. This can
be done by assigning a <em>handle</em> to the started thread and calling the <code>wait()</code> method
to this handle later:</p>
{% set code = "import math\n\nfn p(a f64, b f64) { // ordinary function without return value\n	c := math.sqrt(a * a + b * b)\n	println(c) // prints `5`\n}\n\nfn main() {\n	h := spawn p(3, 4)\n	// p() runs in parallel thread\n	h.wait()\n	// p() has definitely finished\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This approach can also be used to get a return value from a function that is run in a
parallel thread. There is no need to modify the function itself to be able to call it
concurrently.</p>
{% set code = "import math { sqrt }\n\nfn get_hypot(a f64, b f64) f64 { //       ordinary function returning a value\n	c := sqrt(a * a + b * b)\n	return c\n}\n\nfn main() {\n	g := spawn get_hypot(54.06, 2.08) // spawn thread and get handle to it\n	h1 := get_hypot(2.32, 16.74) //   do some other calculation here\n	h2 := g.wait() //                 get result from spawned thread\n	println('Results: ${h1}, ${h2}') //   prints `Results: 16.9, 54.1`\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If there is a large number of tasks, it might be easier to manage them
using an array of threads.</p>
{% set code = "import time\n\nfn task(id int, duration int) {\n	println('task ${id} begin')\n	time.sleep(duration * time.millisecond)\n	println('task ${id} end')\n}\n\nfn main() {\n	mut threads := []thread{}\n	threads << spawn task(1, 500)\n	threads << spawn task(2, 900)\n	threads << spawn task(3, 100)\n	threads.wait()\n	println('done')\n}\n\n// Output:\n// task 1 begin\n// task 2 begin\n// task 3 begin\n// task 3 end\n// task 1 end\n// task 2 end\n// done" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Additionally for threads that return the same type, calling <code>wait()</code>
on the thread array will return all computed values.</p>
{% set code = "fn expensive_computing(i int) int {\n	return i * i\n}\n\nfn main() {\n	mut threads := []thread int{}\n	for i in 1 .. 10 {\n		threads << spawn expensive_computing(i)\n	}\n	// Join all tasks\n	r := threads.wait()\n	println('All jobs finished: ${r}')\n}\n\n// Output: All jobs finished: [1, 4, 9, 16, 25, 36, 49, 64, 81]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="channels"><a class="markdownIt-Anchor" href="#channels">#</a> Channels</h3>
<p>Channels are the preferred way to communicate between threads. V's channels work basically like
those in Go. You can push objects into a channel on one end and pop objects from the other end.
Channels can be buffered or unbuffered and it is possible to <code>select</code> from multiple channels.</p>
<h4 id="syntax-and-usage"><a class="markdownIt-Anchor" href="#syntax-and-usage">#</a> Syntax and Usage</h4>
<p>Channels have the type <code>chan objtype</code>. An optional buffer length can specified as the <code>cap</code> field
in the declaration:</p>
{% set code = "ch := chan int{} // unbuffered - \"synchronous\"\nch2 := chan f64{cap: 100} // buffer length 100" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Channels do not have to be declared as <code>mut</code>. The buffer length is not part of the type but
a field of the individual channel object. Channels can be passed to threads like normal
variables:</p>
{% set code = "fn f(ch chan int) {\n	// ...\n}\n\nfn main() {\n	ch := chan int{}\n	spawn f(ch)\n	// ...\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Objects can be pushed to channels using the arrow operator. The same operator can be used to
pop objects from the other end:</p>
{% set code = "// make buffered channels so pushing does not block (if there is room in the buffer)\nch := chan int{cap: 1}\nch2 := chan f64{cap: 1}\nn := 5\n// push\nch <- n\nch2 <- 7.3\nmut y := f64(0.0)\nm := <-ch // pop creating new variable\ny = <-ch2 // pop into existing variable" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>A channel can be closed to indicate that no further objects can be pushed. Any attempt
to do so will then result in a runtime panic (with the exception of <code>select</code> and
<code>try_push()</code> - see below). Attempts to pop will return immediately if the
associated channel has been closed and the buffer is empty. This situation can be
handled using an <code>or {}</code> block (see <a href="#handling-optionsresults">Handling options/results</a>).</p>
{% set code = "ch := chan int{}\nch2 := chan f64{}\n// ...\nch.close()\n// ...\nm := <-ch or {\n    println('channel has been closed')\n}\n\n// propagate error\ny := <-ch2 ?" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="channel-select"><a class="markdownIt-Anchor" href="#channel-select">#</a> Channel Select</h4>
<p>The <code>select</code> command allows monitoring several channels at the same time
without noticeable CPU load. It consists of a list of possible transfers and associated branches
of statements - similar to the <a href="#match">match</a> command:</p>
{% set code = "import time\n\nfn main() {\n	ch := chan f64{}\n	ch2 := chan f64{}\n	ch3 := chan f64{}\n	mut b := 0.0\n	c := 1.0\n	// ... setup spawn threads that will send on ch/ch2\n	spawn fn (the_channel chan f64) {\n		time.sleep(5 * time.millisecond)\n		the_channel <- 1.0\n	}(ch)\n	spawn fn (the_channel chan f64) {\n		time.sleep(1 * time.millisecond)\n		the_channel <- 1.0\n	}(ch2)\n	spawn fn (the_channel chan f64) {\n		_ := <-the_channel\n	}(ch3)\n\n	select {\n		a := <-ch {\n			// do something with `a`\n			eprintln('> a: ${a}')\n		}\n		b = <-ch2 {\n			// do something with predeclared variable `b`\n			eprintln('> b: ${b}')\n		}\n		ch3 <- c {\n			// do something if `c` was sent\n			time.sleep(5 * time.millisecond)\n			eprintln('> c: ${c} was send on channel ch3')\n		}\n		500 * time.millisecond {\n			// do something if no channel has become ready within 0.5s\n			eprintln('> more than 0.5s passed without a channel being ready')\n		}\n	}\n	eprintln('> done')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The timeout branch is optional. If it is absent <code>select</code> waits for an unlimited amount of time.
It is also possible to proceed immediately if no channel is ready in the moment <code>select</code> is called
by adding an <code>else { ... }</code> branch. <code>else</code> and <code>&lt;timeout&gt;</code> are mutually exclusive.</p>
<p>The <code>select</code> command can be used as an <em>expression</em> of type <code>bool</code>
that becomes <code>false</code> if all channels are closed:</p>
{% set code = "if select {\n    ch <- a {\n        // ...\n    }\n} {\n    // channel was open\n} else {\n    // channel is closed\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h4 id="special-channel-features"><a class="markdownIt-Anchor" href="#special-channel-features">#</a> Special Channel Features</h4>
<p>For special purposes there are some builtin fields and methods:</p>
{% set code = "struct Abc {\n	x int\n}\n\na := 2.13\nch := chan f64{}\nres := ch.try_push(a) // try to perform `ch <- a`\nprintln(res)\nl := ch.len // number of elements in queue\nc := ch.cap // maximum queue length\nis_closed := ch.closed // bool flag - has `ch` been closed\nprintln(l)\nprintln(c)\nmut b := Abc{}\nch2 := chan Abc{}\nres2 := ch2.try_pop(mut b) // try to perform `b = <-ch2`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The <code>try_push/pop()</code> methods will return immediately with one of the results
<code>.success</code>, <code>.not_ready</code> or <code>.closed</code> - dependent on whether the object has been transferred or
the reason why not.
Usage of these methods and fields in production is not recommended -
algorithms based on them are often subject to race conditions. Especially <code>.len</code> and
<code>.closed</code> should not be used to make decisions.
Use <code>or</code> branches, error propagation or <code>select</code> instead (see <a href="#syntax-and-usage">Syntax and Usage</a>
and <a href="#channel-select">Channel Select</a> above).</p>
<h3 id="shared-objects"><a class="markdownIt-Anchor" href="#shared-objects">#</a> Shared Objects</h3>
<p>Data can be exchanged between a thread and the calling thread via a shared variable.
Such variables should be created as <code>shared</code> and passed to the thread as such, too.
The underlying <code>struct</code> contains a hidden <em>mutex</em> that allows locking concurrent access
using <code>rlock</code> for read-only and <code>lock</code> for read/write access.</p>
{% set code = "struct St {\nmut:\n	x int // data to be shared\n}\n\nfn (shared b St) g() {\n	lock b {\n		// read/modify/write b.x\n	}\n}\n\nfn main() {\n	shared a := St{\n		x: 10\n	}\n	spawn a.g()\n	// ...\n	rlock a {\n		// read a.x\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Shared variables must be structs, arrays or maps.</p>
<h2 id="json"><a class="markdownIt-Anchor" href="#json">#</a> JSON</h2>
<p>Because of the ubiquitous nature of JSON, support for it is built directly into V.</p>
<p>V generates code for JSON encoding and decoding.
No runtime reflection is used. This results in much better performance.</p>
<h3 id="decoding-json"><a class="markdownIt-Anchor" href="#decoding-json">#</a> Decoding JSON</h3>
{% set code = "import json\n\nstruct Foo {\n	x int\n}\n\nstruct User {\n	// Adding a [required] attribute will make decoding fail, if that\n	// field is not present in the input.\n	// If a field is not [required], but is missing, it will be assumed\n	// to have its default value, like 0 for numbers, or '' for strings,\n	// and decoding will not fail.\n	name string [required]\n	age  int\n	// Use the `skip` attribute to skip certain fields\n	foo Foo [skip]\n	// If the field name is different in JSON, it can be specified\n	last_name string [json: lastName]\n}\n\ndata := '{ \"name\": \"Frodo\", \"lastName\": \"Baggins\", \"age\": 25 }'\nuser := json.decode(User, data) or {\n	eprintln('Failed to decode json, error: ${err}')\n	return\n}\nprintln(user.name)\nprintln(user.last_name)\nprintln(user.age)\n// You can also decode JSON arrays:\nsfoos := '[{\"x\":123},{\"x\":456}]'\nfoos := json.decode([]Foo, sfoos)!\nprintln(foos[0].x)\nprintln(foos[1].x)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The <code>json.decode</code> function takes two arguments:
the first is the type into which the JSON value should be decoded and
the second is a string containing the JSON data.</p>
<h3 id="encoding-json"><a class="markdownIt-Anchor" href="#encoding-json">#</a> Encoding JSON</h3>
{% set code = "import json\n\nstruct User {\n	name  string\n	score i64\n}\n\nmut data := map[string]int{}\nuser := &User{\n	name: 'Pierre'\n	score: 1024\n}\n\ndata['x'] = 42\ndata['y'] = 360\n\nprintln(json.encode(data)) // {\"x\":42,\"y\":360}\nprintln(json.encode(user)) // {\"name\":\"Pierre\",\"score\":1024}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="testing"><a class="markdownIt-Anchor" href="#testing">#</a> Testing</h2>
<h3 id="asserts"><a class="markdownIt-Anchor" href="#asserts">#</a> Asserts</h3>
{% set code = "fn foo(mut v []int) {\n	v[0] = 1\n}\n\nmut v := [20]\nfoo(mut v)\nassert v[0] < 4" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>An <code>assert</code> statement checks that its expression evaluates to <code>true</code>. If an assert fails,
the program will usually abort. Asserts should only be used to detect programming errors. When an
assert fails it is reported to <em>stderr</em>, and the values on each side of a comparison operator
(such as <code>&lt;</code>, <code>==</code>) will be printed when possible. This is useful to easily find an
unexpected value. Assert statements can be used in any function, not just test ones,
which is handy when developing new functionality, to keep your invariants in check.</p>
<blockquote>
<p><strong>Note</strong>
All <code>assert</code> statements are <em>removed</em>, when you compile your program with the <code>-prod</code> flag.</p>
</blockquote>
<h3 id="asserts-with-an-extra-message"><a class="markdownIt-Anchor" href="#asserts-with-an-extra-message">#</a> Asserts with an extra message</h3>
<p>This form of the <code>assert</code> statement, will print the extra message when it fails. Note, that
you can use any string expression there - string literals, functions returning a string,
strings that interpolate variables, etc.</p>
{% set code = "fn test_assertion_with_extra_message_failure() {\n	for i in 0 .. 100 {\n		assert i * 2 - 45 < 75 + 10, 'assertion failed for i: ${i}'\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="asserts-that-do-not-abort-your-program"><a class="markdownIt-Anchor" href="#asserts-that-do-not-abort-your-program">#</a> Asserts that do not abort your program</h3>
<p>When initially prototyping functionality and tests, it is sometimes desirable to
have asserts, that do not stop the program, but just print their failures. That can
be achieved by tagging your assert containing functions with an <code>[assert_continues]</code>
tag, for example running this program:</p>
{% set code = "[assert_continues]\nfn abc(ii int) {\n	assert ii == 2\n}\n\nfor i in 0 .. 4 {\n	abc(i)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>... will produce this output:</p>
{% set code = "assert_continues_example.v:3: FAIL: fn main.abc: assert ii == 2\n   left value: ii = 0\n   right value: 2\nassert_continues_example.v:3: FAIL: fn main.abc: assert ii == 2\n   left value: ii = 1\n  right value: 2\nassert_continues_example.v:3: FAIL: fn main.abc: assert ii == 2\n   left value: ii = 3\n  right value: 2" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
V also supports a command line flag <code>-assert continues</code>, which will change the
behaviour of all asserts globally, as if you had tagged every function with <code>[assert_continues]</code>.</p>
</blockquote>
<h3 id="test-files"><a class="markdownIt-Anchor" href="#test-files">#</a> Test files</h3>
{% set code = "// hello.v\nmodule main\n\nfn hello() string {\n	return 'Hello world'\n}\n\nfn main() {\n	println(hello())\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "// hello_test.v\nmodule main\n\nfn test_hello() {\n	assert hello() == 'Hello world'\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>To run the test file above, use <code>v hello_test.v</code>. This will check that the function <code>hello</code> is
producing the correct output. V executes all test functions in the file.</p>
<blockquote>
<p><strong>Note</strong>
All <code>_test.v</code> files (both external and internal ones), are compiled as <em>separate programs</em>.
In other words, you may have as many <code>_test.v</code> files, and tests in them as you like, they will
not affect the compilation of your other code in <code>.v</code> files normally at all, but only when you
do explicitly <code>v file_test.v</code> or <code>v test .</code>.</p>
</blockquote>
<ul>
<li>All test functions have to be inside a test file whose name ends in <code>_test.v</code>.</li>
<li>Test function names must begin with <code>test_</code> to mark them for execution.</li>
<li>Normal functions can also be defined in test files, and should be called manually. Other
symbols can also be defined in test files e.g. types.</li>
<li>There are two kinds of tests: external and internal.</li>
<li>Internal tests must <em>declare</em> their module, just like all other .v
files from the same module. Internal tests can even call private functions in
the same module.</li>
<li>External tests must <em>import</em> the modules which they test. They do not
have access to the private functions/types of the modules. They can test only
the external/public API that a module provides.</li>
</ul>
<p>In the example above, <code>test_hello</code> is an internal test, that can call
the private function <code>hello()</code> because <code>hello_test.v</code> has <code>module main</code>,
just like <code>hello.v</code>, i.e. both are part of the same module. Note also that
since <code>module main</code> is a regular module like the others, internal tests can
be used to test private functions in your main program .v files too.</p>
<p>You can also define these special test functions in a test file:</p>
<ul>
<li><code>testsuite_begin</code> which will be run <em>before</em> all other test functions.</li>
<li><code>testsuite_end</code> which will be run <em>after</em> all other test functions.</li>
</ul>
<p>If a test function has an error return type, any propagated errors will fail the test:</p>
{% set code = "import strconv\n\nfn test_atoi() ? {\n	assert strconv.atoi('1')? == 1\n	assert strconv.atoi('one')? == 1 // test will fail\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="running-tests"><a class="markdownIt-Anchor" href="#running-tests">#</a> Running tests</h3>
<p>To run test functions in an individual test file, use <code>v foo_test.v</code>.</p>
<p>To test an entire module, use <code>v test mymodule</code>. You can also use <code>v test .</code> to test
everything inside your current folder (and subfolders). You can pass the <code>-stats</code>
option to see more details about the individual tests run.</p>
<p>You can put additional test data, including .v source files in a folder, named
<code>testdata</code>, right next to your _test.v files. V's test framework will <em>ignore</em>
such folders, while scanning for tests to run. This is useful, if you want to
put .v files with invalid V source code, or other tests, including known
failing ones, that should be run in a specific way/options by a parent _test.v
file.</p>
<blockquote>
<p><strong>Note</strong>
The path to the V compiler, is available through @VEXE, so a _test.v
file, can easily run <em>other</em> test files like this:</p>
</blockquote>
{% set code = "import os\n\nfn test_subtest() {\n	res := os.execute('${os.quoted_path(@VEXE)} other_test.v')\n	assert res.exit_code == 1\n	assert res.output.contains('other_test.v does not exist')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="memory-management"><a class="markdownIt-Anchor" href="#memory-management">#</a> Memory management</h2>
<p>V avoids doing unnecessary allocations in the first place by using value types,
string buffers, promoting a simple abstraction-free code style.</p>
<p>Most objects (~90-100%) are freed by V's autofree engine: the compiler inserts
necessary free calls automatically during compilation. Remaining small percentage
of objects is freed via reference counting.</p>
<p>The developer doesn't need to change anything in their code. &quot;It just works&quot;, like in
Python, Go, or Java, except there's no heavy GC tracing everything or expensive RC for
each object.</p>
<h3 id="control"><a class="markdownIt-Anchor" href="#control">#</a> Control</h3>
<p>You can take advantage of V's autofree engine and define a <code>free()</code> method on custom
data types:</p>
{% set code = "struct MyType {}\n\n[unsafe]\nfn (data &MyType) free() {\n	// ...\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Just as the compiler frees C data types with C's <code>free()</code>, it will statically insert
<code>free()</code> calls for your data type at the end of each variable's lifetime.</p>
<p>Autofree can be enabled with an <code>-autofree</code> flag.</p>
<p>For developers willing to have more low level control, autofree can be disabled with
<code>-manualfree</code>, or by adding a <code>[manualfree]</code> on each function that wants manage its
memory manually. (See <a href="#attributes">attributes</a>).</p>
<blockquote>
<p><strong>Note</strong>
Autofree is still WIP. Until it stabilises and becomes the default, please
avoid using it. Right now allocations are handled by a minimal and well performing GC
until V's autofree engine is production ready.</p>
</blockquote>
<p><strong>Examples</strong></p>
{% set code = "import strings\n\nfn draw_text(s string, x int, y int) {\n	// ...\n}\n\nfn draw_scene() {\n	// ...\n	name1 := 'abc'\n	name2 := 'def ghi'\n	draw_text('hello ${name1}', 10, 10)\n	draw_text('hello ${name2}', 100, 10)\n	draw_text(strings.repeat(`X`, 10000), 10, 50)\n	// ...\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The strings don't escape <code>draw_text</code>, so they are cleaned up when
the function exits.</p>
<p>In fact, with the <code>-prealloc</code> flag, the first two calls won't result in any allocations at all.
These two strings are small, so V will use a preallocated buffer for them.</p>
{% set code = "struct User {\n	name string\n}\n\nfn test() []int {\n	number := 7 // stack variable\n	user := User{} // struct allocated on stack\n	numbers := [1, 2, 3] // array allocated on heap, will be freed as the function exits\n	println(number)\n	println(user)\n	println(numbers)\n	numbers2 := [4, 5, 6] // array that's being returned, won't be freed here\n	return numbers2\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="stack-and-heap"><a class="markdownIt-Anchor" href="#stack-and-heap">#</a> Stack and Heap</h3>
<h4 id="stack-and-heap-basics"><a class="markdownIt-Anchor" href="#stack-and-heap-basics">#</a> Stack and Heap Basics</h4>
<p>Like with most other programming languages there are two locations where data can
be stored:</p>
<ul>
<li>The <em>stack</em> allows fast allocations with almost zero administrative overhead. The
stack grows and shrinks with the function call depth ‚Äì so every called
function has its stack segment that remains valid until the function returns.
No freeing is necessary, however, this also means that a reference to a stack
object becomes invalid on function return. Furthermore stack space is
limited (typically to a few Megabytes per thread).</li>
<li>The <em>heap</em> is a large memory area (typically some Gigabytes) that is administrated
by the operating system. Heap objects are allocated and freed by special function
calls that delegate the administrative tasks to the OS. This means that they can
remain valid across several function calls, however, the administration is
expensive.</li>
</ul>
<h4 id="vs-default-approach"><a class="markdownIt-Anchor" href="#vs-default-approach">#</a> V's default approach</h4>
<p>Due to performance considerations V tries to put objects on the stack if possible
but allocates them on the heap when obviously necessary. Example:</p>
{% set code = "struct MyStruct {\n	n int\n}\n\nstruct RefStruct {\n	r &MyStruct\n}\n\nfn main() {\n	q, w := f()\n	println('q: ${q.r.n}, w: ${w.n}')\n}\n\nfn f() (RefStruct, &MyStruct) {\n	a := MyStruct{\n		n: 1\n	}\n	b := MyStruct{\n		n: 2\n	}\n	c := MyStruct{\n		n: 3\n	}\n	e := RefStruct{\n		r: &b\n	}\n	x := a.n + c.n\n	println('x: ${x}')\n	return e, &c\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Here <code>a</code> is stored on the stack since it's address never leaves the function <code>f()</code>.
However a reference to <code>b</code> is part of <code>e</code> which is returned. Also a reference to
<code>c</code> is returned. For this reason <code>b</code> and <code>c</code> will be heap allocated.</p>
<p>Things become less obvious when a reference to an object is passed as function argument:</p>
{% set code = "struct MyStruct {\nmut:\n	n int\n}\n\nfn main() {\n	mut q := MyStruct{\n		n: 7\n	}\n	w := MyStruct{\n		n: 13\n	}\n	x := q.f(&w) // references of `q` and `w` are passed\n	println('q: ${q}\nx: ${x}')\n}\n\nfn (mut a MyStruct) f(b &MyStruct) int {\n	a.n += b.n\n	x := a.n * b.n\n	return x\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Here the call <code>q.f(&amp;w)</code> passes references to <code>q</code> and <code>w</code> because <code>a</code> is
<code>mut</code> and <code>b</code> is of type <code>&amp;MyStruct</code> in <code>f()</code>'s declaration, so technically
these references are leaving <code>main()</code>. However the <em>lifetime</em> of these
references lies inside the scope of <code>main()</code> so <code>q</code> and <code>w</code> are allocated
on the stack.</p>
<h4 id="manual-control-for-stack-and-heap"><a class="markdownIt-Anchor" href="#manual-control-for-stack-and-heap">#</a> Manual Control for Stack and Heap</h4>
<p>In the last example the V compiler could put <code>q</code> and <code>w</code> on the stack
because it assumed that in the call <code>q.f(&amp;w)</code> these references were only
used for reading and modifying the referred values ‚Äì and not to pass the
references themselves somewhere else. This can be seen in a way that the
references to <code>q</code> and <code>w</code> are only <em>borrowed</em> to <code>f()</code>.</p>
<p>Things become different if <code>f()</code> is doing something with a reference itself:</p>
{% set code = "struct RefStruct {\nmut:\n	r &MyStruct\n}\n\n// see discussion below\n[heap]\nstruct MyStruct {\n	n int\n}\n\nfn main() {\n	m := MyStruct{}\n	mut r := RefStruct{\n		r: &m\n	}\n	r.g()\n	println('r: ${r}')\n}\n\nfn (mut r RefStruct) g() {\n	s := MyStruct{\n		n: 7\n	}\n	r.f(&s) // reference to `s` inside `r` is passed back to `main() `\n}\n\nfn (mut r RefStruct) f(s &MyStruct) {\n	r.r = s // would trigger error without `[heap]`\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Here <code>f()</code> looks quite innocent but is doing nasty things ‚Äì it inserts a
reference to <code>s</code> into <code>r</code>. The problem with this is that <code>s</code> lives only as long
as <code>g()</code> is running but <code>r</code> is used in <code>main()</code> after that. For this reason
the compiler would complain about the assignment in <code>f()</code> because <code>s</code> <em>&quot;might
refer to an object stored on stack&quot;</em>. The assumption made in <code>g()</code> that the call
<code>r.f(&amp;s)</code> would only borrow the reference to <code>s</code> is wrong.</p>
<p>A solution to this dilemma is the <code>[heap]</code> <a href="#attributes">attribute</a> at the declaration of
<code>struct MyStruct</code>. It instructs the compiler to <em>always</em> allocate <code>MyStruct</code>-objects
on the heap. This way the reference to <code>s</code> remains valid even after <code>g()</code> returns.
The compiler takes into consideration that <code>MyStruct</code> objects are always heap
allocated when checking <code>f()</code> and allows assigning the reference to <code>s</code> to the
<code>r.r</code> field.</p>
<p>There is a pattern often seen in other programming languages:</p>
{% set code = "fn (mut a MyStruct) f() &MyStruct {\n	// do something with a\n	return &a // would return address of borrowed object\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Here <code>f()</code> is passed a reference <code>a</code> as receiver that is passed back to the caller and returned
as result at the same time. The intention behind such a declaration is method chaining like
<code>y = x.f().g()</code>. However, the problem with this approach is that a second reference
to <code>a</code> is created ‚Äì so it is not only borrowed and <code>MyStruct</code> has to be
declared as <code>[heap]</code>.</p>
<p>In V the better approach is:</p>
{% set code = "struct MyStruct {\nmut:\n	n int\n}\n\nfn (mut a MyStruct) f() {\n	// do something with `a`\n}\n\nfn (mut a MyStruct) g() {\n	// do something else with `a`\n}\n\nfn main() {\n	x := MyStruct{} // stack allocated\n	mut y := x\n	y.f()\n	y.g()\n	// instead of `mut y := x.f().g()\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This way the <code>[heap]</code> attribute can be avoided ‚Äì resulting in better performance.</p>
<p>However, stack space is very limited as mentioned above. For this reason the <code>[heap]</code>
attribute might be suitable for very large structures even if not required by use cases
like those mentioned above.</p>
<p>There is an alternative way to manually control allocation on a case to case basis. This
approach is not recommended but shown here for the sake of completeness:</p>
{% set code = "struct MyStruct {\n	n int\n}\n\nstruct RefStruct {\nmut:\n	r &MyStruct\n}\n\n// simple function - just to overwrite stack segment previously used by `g()`\n\nfn use_stack() {\n	x := 7.5\n	y := 3.25\n	z := x + y\n	println('${x} ${y} ${z}')\n}\n\nfn main() {\n	m := MyStruct{}\n	mut r := RefStruct{\n		r: &m\n	}\n	r.g()\n	use_stack() // to erase invalid stack contents\n	println('r: ${r}')\n}\n\nfn (mut r RefStruct) g() {\n	s := &MyStruct{ // `s` explicitly refers to a heap object\n		n: 7\n	}\n	// change `&MyStruct` -> `MyStruct` above and `r.f(s)` -> `r.f(&s)` below\n	// to see data in stack segment being overwritten\n	r.f(s)\n}\n\nfn (mut r RefStruct) f(s &MyStruct) {\n	r.r = unsafe { s } // override compiler check\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Here the compiler check is suppressed by the <code>unsafe</code> block. To make <code>s</code> be heap
allocated even without <code>[heap]</code> attribute the <code>struct</code> literal is prefixed with
an ampersand: <code>&amp;MyStruct{...}</code>.</p>
<p>This last step would not be required by the compiler but without it the reference
inside <code>r</code> becomes invalid (the memory area pointed to will be overwritten by
<code>use_stack()</code>) and the program might crash (or at least produce an unpredictable
final output). That's why this approach is <em>unsafe</em> and should be avoided!</p>
<h2 id="orm"><a class="markdownIt-Anchor" href="#orm">#</a> ORM</h2>
<p>(This is still in an alpha state)</p>
<p>V has a built-in ORM (object-relational mapping) which supports SQLite, MySQL and Postgres,
but soon it will support MS SQL and Oracle.</p>
<p>V's ORM provides a number of benefits:</p>
<ul>
<li>One syntax for all SQL dialects. (Migrating between databases becomes much easier.)</li>
<li>Queries are constructed using V's syntax. (There's no need to learn another syntax.)</li>
<li>Safety. (All queries are automatically sanitised to prevent SQL injection.)</li>
<li>Compile time checks. (This prevents typos which can only be caught during runtime.)</li>
<li>Readability and simplicity. (You don't need to manually parse the results of a query and
then manually construct objects from the parsed results.)</li>
</ul>
{% set code = "import db.sqlite\n\n// sets a custom table name. Default is struct name (case-sensitive)\n[table: 'customers']\nstruct Customer {\n	id        int    [primary; sql: serial] // a field named `id` of integer type must be the first field\n	name      string [nonull]\n	nr_orders int\n	country   string [nonull]\n}\n\ndb := sqlite.connect('customers.db')?\n\n// you can create tables:\n// CREATE TABLE IF NOT EXISTS `Customer` (\n//      `id` INTEGER PRIMARY KEY,\n//      `name` TEXT NOT NULL,\n//      `nr_orders` INTEGER,\n//      `country` TEXT NOT NULL\n// )\nsql db {\n	create table Customer\n}\n\n// select count(*) from customers\nnr_customers := sql db {\n	select count from Customer\n}\nprintln('number of all customers: ${nr_customers}')\n// V syntax can be used to build queries\nuk_customers := sql db {\n	select from Customer where country == 'uk' && nr_orders > 0\n}\nprintln(uk_customers.len)\nfor customer in uk_customers {\n	println('${customer.id} - ${customer.name}')\n}\n// by adding `limit 1` we tell V that there will be only one object\ncustomer := sql db {\n	select from Customer where id == 1 limit 1\n}\nprintln('${customer.id} - ${customer.name}')\n// insert a new customer\nnew_customer := Customer{\n	name: 'Bob'\n	nr_orders: 10\n}\nsql db {\n	insert new_customer into Customer\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>For more examples and the docs, see <a href="https://github.com/vlang/v/tree/master/vlib/orm">vlib/orm</a>.</p>
<h2 id="writing-documentation"><a class="markdownIt-Anchor" href="#writing-documentation">#</a> Writing Documentation</h2>
<p>The way it works is very similar to Go. It's very simple: there's no need to
write documentation separately for your code,
vdoc will generate it from docstrings in the source code.</p>
<p>Documentation for each function/type/const must be placed right before the declaration:</p>
{% set code = "// clearall clears all bits in the array\n\nfn clearall() {\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The comment must start with the name of the definition.</p>
<p>Sometimes one line isn't enough to explain what a function does, in that case comments should
span to the documented function using single line comments:</p>
{% set code = "// copy_all recursively copies all elements of the array by their value,\n// if `dupes` is false all duplicate values are eliminated in the process.\n\nfn copy_all(dupes bool) {\n	// ...\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>By convention it is preferred that comments are written in <em>present tense</em>.</p>
<p>An overview of the module must be placed in the first comment right after the module's name.</p>
<p>To generate documentation use vdoc, for example <code>v doc net.http</code>.</p>
<h3 id="newlines-in-documentation-comments"><a class="markdownIt-Anchor" href="#newlines-in-documentation-comments">#</a> Newlines in Documentation Comments</h3>
<p>Comments spanning multiple lines are merged together using spaces, unless</p>
<ul>
<li>the line is empty</li>
<li>the line ends with a <code>.</code> (end of sentence)</li>
<li>the line is purely of at least 3 of <code>-</code>, <code>=</code>, <code>_</code>, <code>*</code>, <code>~</code> (horizontal rule)</li>
<li>the line starts with at least one <code>#</code> followed by a space (header)</li>
<li>the line starts and ends with a <code>|</code> (table)</li>
<li>the line starts with <code>- </code> (list)</li>
</ul>
<h2 id="tools"><a class="markdownIt-Anchor" href="#tools">#</a> Tools</h2>
<h3 id="v-fmt"><a class="markdownIt-Anchor" href="#v-fmt">#</a> v fmt</h3>
<p>You don't need to worry about formatting your code or setting style guidelines.
<code>v fmt</code> takes care of that:</p>
{% set code = "v fmt file.v" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>It's recommended to set up your editor, so that <code>v fmt -w</code> runs on every save.
A vfmt run is usually pretty cheap (takes &lt;30ms).</p>
<p>Always run <code>v fmt -w file.v</code> before pushing your code.</p>
<h4 id="disabling-the-formatting-locally"><a class="markdownIt-Anchor" href="#disabling-the-formatting-locally">#</a> Disabling the formatting locally</h4>
<p>To disable formatting for a block of code, wrap it with <code>// vfmt off</code> and
<code>// vfmt on</code> comments.</p>
{% set code = "// Not affected by fmt\n// vfmt off\n\n... your code here ...\n\n// vfmt on\n\n// Affected by fmt\n... your code here ..." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="v-shader"><a class="markdownIt-Anchor" href="#v-shader">#</a> v shader</h3>
<p>You can use GPU shaders with V graphical apps. You write your shaders in an
<a href="https://github.com/vlang/v/blob/1d8ece7/examples/sokol/02_cubes_glsl/cube_glsl.glsl">annotated GLSL dialect</a>
and use <code>v shader</code> to compile them for all supported target platforms.</p>
{% set code = "v shader /path/to/project/dir/or/file.v" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Currently you need to
<a href="https://github.com/vlang/v/blob/c14c324/examples/sokol/02_cubes_glsl/cube_glsl.v#L43-L46">include a header and declare a glue function</a>
before using the shader in your code.</p>
<h3 id="profiling"><a class="markdownIt-Anchor" href="#profiling">#</a> Profiling</h3>
<p>V has good support for profiling your programs: <code>v -profile profile.txt run file.v</code>
That will produce a profile.txt file, which you can then analyze.</p>
<p>The generated profile.txt file will have lines with 4 columns:
a) how many times a function was called
b) how much time in total a function took (in ms)
c) how much time on average, a call to a function took (in ns)
d) the name of the v function</p>
<p>You can sort on column 3 (average time per function) using:
<code>sort -n -k3 profile.txt|tail</code></p>
<p>You can also use stopwatches to measure just portions of your code explicitly:</p>
{% set code = "import time\n\nfn main() {\n	sw := time.new_stopwatch()\n	println('Hello world')\n	println('Greeting the world took: ${sw.elapsed().nanoseconds()}ns')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="package-management"><a class="markdownIt-Anchor" href="#package-management">#</a> Package management</h2>
<p>A V <em>module</em> is a single folder with .v files inside. A V <em>package</em> can
contain one or more V modules. A V <em>package</em> should have a <code>v.mod</code> file
at its top folder, describing the contents of the package.</p>
<p>V packages are installed normally in your <code>~/.vmodules</code> folder. That
location can be overridden by setting the env variable <code>VMODULES</code>.</p>
<h3 id="package-commands"><a class="markdownIt-Anchor" href="#package-commands">#</a> Package commands</h3>
<p>You can use the V frontend to do package operations, just like you can
use it for compiling code, formatting code, vetting code etc.</p>
{% set code = "v [package_command] [param]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>where a package command can be one of:</p>
{% set code = "   install           Install a package from VPM.\n   remove            Remove a package that was installed from VPM.\n   search            Search for a package from VPM.\n   update            Update an installed package from VPM.\n   upgrade           Upgrade all the outdated packages.\n   list              List all installed packages.\n   outdated          Show installed packages that need updates." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>You can install packages already created by someone else with <a href="https://vpm.vlang.io/">VPM</a>:</p>
{% set code = "v install [package]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><strong>Example:</strong></p>
{% set code = "v install ui" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Packages can be installed directly from git or mercurial repositories.</p>
{% set code = "v install [--once] [--git|--hg] [url]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><strong>Example:</strong></p>
{% set code = "v install --git https://github.com/vlang/markdown" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Sometimes you may want to install the dependencies <strong>ONLY</strong> if those are not installed:</p>
{% set code = "v install --once [package]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Removing a package with v:</p>
{% set code = "v remove [package]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><strong>Example:</strong></p>
{% set code = "v remove ui" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Updating an installed package from <a href="https://vpm.vlang.io/">VPM</a>:</p>
{% set code = "v update [package]" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><strong>Example:</strong></p>
{% set code = "v update ui" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Or you can update all your packages:</p>
{% set code = "v update" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>To see all the packages you have installed, you can use:</p>
{% set code = "v list" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><strong>Example:</strong></p>
{% set code = "> v list\nInstalled packages:\n  markdown\n  ui" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>To see all the packages that need updates:</p>
{% set code = "v outdated" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><strong>Example:</strong></p>
{% set code = "> v outdated\nPackage are up to date." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="publish-package"><a class="markdownIt-Anchor" href="#publish-package">#</a> Publish package</h3>
<ol>
<li>
<p>Put a <code>v.mod</code> file inside the toplevel folder of your package (if you
created your package with the command <code>v new mypackage</code> or <code>v init</code>
you already have a <code>v.mod</code> file).</p>
{% set code = "v new mypackage\nInput your project description: My nice package.\nInput your project version: (0.0.0) 0.0.1\nInput your project license: (MIT)\nInitialising ...\nComplete!" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Example <code>v.mod</code>:</p>
{% set code = "Module {\n    name: 'mypackage'\n    description: 'My nice package.'\n    version: '0.0.1'\n    license: 'MIT'\n    dependencies: []\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Minimal file structure:</p>
{% set code = "v.mod\nmypackage.v" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The name of your package should be used with the <code>module</code> directive
at the top of all files in your package. For <code>mypackage.v</code>:</p>
{% set code = "module mypackage\n\npub fn hello_world() {\n    println('Hello World!')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
</li>
<li>
<p>Create a git repository in the folder with the <code>v.mod</code> file
(this is not required if you used <code>v new</code> or <code>v init</code>):</p>
{% set code = "git init\ngit add .\ngit commit -m \"INIT\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
</li>
<li>
<p>Create a public repository on github.com.</p>
</li>
<li>
<p>Connect your local repository to the remote repository and push the changes.</p>
</li>
<li>
<p>Add your package to the public V package registry VPM:
https://vpm.vlang.io/new</p>
<p>You will have to login with your Github account to register the package.
<strong>Warning:</strong> <em>Currently it is not possible to edit your entry after submitting.
Check your package name and github url twice as this cannot be changed by you later.</em></p>
</li>
<li>
<p>The final package name is a combination of your github account and
the package name you provided e.g. <code>mygithubname.mypackage</code>.</p>
</li>
</ol>
<p><strong>Optional:</strong> tag your V package with <code>vlang</code> and <code>vlang-package</code> on github.com
to allow for a better search experience.</p>
<h1 id="advanced-topics"><a class="markdownIt-Anchor" href="#advanced-topics">#</a> Advanced Topics</h1>
<h2 id="attributes"><a class="markdownIt-Anchor" href="#attributes">#</a> Attributes</h2>
<p>V has several attributes that modify the behavior of functions and structs.</p>
<p>An attribute is a compiler instruction specified inside <code>[]</code> right before a
function/struct/enum declaration and applies only to the following declaration.</p>
{% set code = "// [flag] enables Enum types to be used as bitfields\n\n[flag]\nenum BitField {\n	read\n	write\n	other\n}\n\nfn main() {\n	assert 1 == int(BitField.read)\n	assert 2 == int(BitField.write)\n	mut bf := BitField.read\n	assert bf.has(.read | .other) // test if *at least one* of the flags is set\n	assert !bf.all(.read | .other) // test if *all* of the flags is set\n	bf.set(.write | .other)\n	assert bf.has(.read | .write | .other)\n	assert bf.all(.read | .write | .other)\n	bf.toggle(.other)\n	assert bf == BitField.read | .write\n	assert bf.all(.read | .write)\n	assert !bf.has(.other)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Struct field deprecations:</p>
{% set code = "module abc\n\n// Note that only *direct* accesses to Xyz.d in *other modules*, will produce deprecation notices/warnings:\npub struct Xyz {\npub mut:\n	a int\n	d int [deprecated: 'use Xyz.a instead'; deprecated_after: '2999-03-01']\n	// the tags above, will produce a notice, since the deprecation date is in the far future\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Function/method deprecations:</p>
{% set code = "// Calling this function will result in a deprecation warning\n\n[deprecated]\nfn old_function() {\n}\n\n// It can also display a custom deprecation message\n\n[deprecated: 'use new_function() instead']\nfn legacy_function() {}\n\n// You can also specify a date, after which the function will be\n// considered deprecated. Before that date, calls to the function\n// will be compiler notices - you will see them, but the compilation\n// is not affected. After that date, calls will become warnings,\n// so ordinary compiling will still work, but compiling with -prod\n// will not (all warnings are treated like errors with -prod).\n// 6 months after the deprecation date, calls will be hard\n// compiler errors.\n\n[deprecated: 'use new_function2() instead']\n[deprecated_after: '2021-05-27']\nfn legacy_function2() {}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
{% set code = "// This function's calls will be inlined.\n[inline]\nfn inlined_function() {\n}\n\n// This function's calls will NOT be inlined.\n[noinline]\nfn function() {\n}\n\n// This function will NOT return to its callers.\n// Such functions can be used at the end of or blocks,\n// just like exit/1 or panic/1. Such functions can not\n// have return types, and should end either in for{}, or\n// by calling other `[noreturn]` functions.\n[noreturn]\nfn forever() {\n	for {}\n}\n\n// The following struct must be allocated on the heap. Therefore, it can only be used as a\n// reference (`&Window`) or inside another reference (`&OuterStruct{ Window{...} }`).\n// See section \"Stack and Heap\"\n[heap]\nstruct Window {\n}\n\n// V will not generate this function and all its calls if the provided flag is false.\n// To use a flag, use `v -d flag`\n[if debug]\nfn foo() {\n}\n\nfn bar() {\n	foo() // will not be called if `-d debug` is not passed\n}\n\n// The memory pointed to by the pointer arguments of this function will not be\n// freed by the garbage collector (if in use) before the function returns\n[keep_args_alive]\nfn C.my_external_function(voidptr, int, voidptr) int\n\n// Calls to following function must be in unsafe{} blocks.\n// Note that the code in the body of `risky_business()` will still be\n// checked, unless you also wrap it in `unsafe {}` blocks.\n// This is useful, when you want to have an `[unsafe]` function that\n// has checks before/after a certain unsafe operation, that will still\n// benefit from V's safety features.\n[unsafe]\nfn risky_business() {\n	// code that will be checked, perhaps checking pre conditions\n	unsafe {\n		// code that *will not be* checked, like pointer arithmetic,\n		// accessing union fields, calling other `[unsafe]` fns, etc...\n		// Usually, it is a good idea to try minimizing code wrapped\n		// in unsafe{} as much as possible.\n		// See also [Memory-unsafe code](#memory-unsafe-code)\n	}\n	// code that will be checked, perhaps checking post conditions and/or\n	// keeping invariants\n}\n\n// V's autofree engine will not take care of memory management in this function.\n// You will have the responsibility to free memory manually yourself in it.\n[manualfree]\nfn custom_allocations() {\n}\n\n// For C interop only, tells V that the following struct is defined with `typedef struct` in C\n[typedef]\nstruct C.Foo {\n}\n\n// Used to add a custom calling convention to a function, available calling convention: stdcall, fastcall and cdecl.\n// This list also applies for type aliases (see below).\n[callconv: \"stdcall\"]\nfn C.DefWindowProc(hwnd int, msg int, lparam int, wparam int)\n\n// Used to add a custom calling convention to a function type aliases.\n[callconv: \"fastcall\"]\ntype FastFn = fn (int) bool\n\n// Windows only:\n// Without this attribute all graphical apps will have the following behavior on Windows:\n// If run from a console or terminal; keep the terminal open so all (e)println statements can be viewed.\n// If run from e.g. Explorer, by double-click; app is opened, but no terminal is opened, and no (e)println output can be seen.\n// Use it to force-open a terminal to view output in, even if the app is started from Explorer.\n// Valid before main() only.\n[console]\nfn main() {\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="conditional-compilation"><a class="markdownIt-Anchor" href="#conditional-compilation">#</a> Conditional compilation</h2>
<h3 id="compile-time-pseudo-variables"><a class="markdownIt-Anchor" href="#compile-time-pseudo-variables">#</a> Compile time pseudo variables</h3>
<p>V also gives your code access to a set of pseudo string variables,
that are substituted at compile time:</p>
<ul>
<li><code>@FN</code> =&gt; replaced with the name of the current V function</li>
<li><code>@METHOD</code> =&gt; replaced with ReceiverType.MethodName</li>
<li><code>@MOD</code> =&gt; replaced with the name of the current V module</li>
<li><code>@STRUCT</code> =&gt; replaced with the name of the current V struct</li>
<li><code>@FILE</code> =&gt; replaced with the absolute path of the V source file</li>
<li><code>@LINE</code> =&gt; replaced with the V line number where it appears (as a string).</li>
<li><code>@FILE_LINE</code> =&gt; like <code>@FILE:@LINE</code>, but the file part is a relative path</li>
<li><code>@COLUMN</code> =&gt; replaced with the column where it appears (as a string).</li>
<li><code>@VEXE</code> =&gt; replaced with the path to the V compiler</li>
<li><code>@VEXEROOT</code>  =&gt; will be substituted with the <em>folder</em>,
where the V executable is (as a string).</li>
<li><code>@VHASH</code>  =&gt; replaced with the shortened commit hash of the V compiler (as a string).</li>
<li><code>@VMOD_FILE</code> =&gt; replaced with the contents of the nearest v.mod file (as a string).</li>
<li><code>@VMODROOT</code> =&gt; will be substituted with the <em>folder</em>,
where the nearest v.mod file is (as a string).</li>
</ul>
<p>That allows you to do the following example, useful while debugging/logging/tracing your code:</p>
{% set code = "eprintln('file: ' + @FILE + ' | line: ' + @LINE + ' | fn: ' + @MOD + '.' + @FN)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Another example, is if you want to embed the version/name from v.mod <em>inside</em> your executable:</p>
{% set code = "import v.vmod\nvm := vmod.decode( @VMOD_FILE ) or { panic(err) }\neprintln('${vm.name} ${vm.version}\n ${vm.description}')" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="compile-time-reflection"><a class="markdownIt-Anchor" href="#compile-time-reflection">#</a> Compile-time reflection</h3>
<p>Having built-in JSON support is nice, but V also allows you to create efficient
serializers for any data format. V has compile-time <code>if</code> and <code>for</code> constructs:</p>
{% set code = "struct User {\n	name string\n	age  int\n}\n\nfn main() {\n	$for field in User.fields {\n		$if field.typ is string {\n			println('${field.name} is of type string')\n		}\n	}\n}\n\n// Output:\n// name is of type string" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>See <a href="/examples/compiletime/reflection.v"><code>examples/compiletime/reflection.v</code></a>
for a more complete example.</p>
<h3 id="compile-time-code"><a class="markdownIt-Anchor" href="#compile-time-code">#</a> Compile time code</h3>
<p><code>$</code> is used as a prefix for compile-time operations.</p>
<h4 id="if-condition"><a class="markdownIt-Anchor" href="#if-condition">#</a> <code>$if</code> condition</h4>
{% set code = "fn main() {\n	// Support for multiple conditions in one branch\n	$if ios || android {\n		println('Running on a mobile device!')\n	}\n	$if linux && x64 {\n		println('64-bit Linux.')\n	}\n	// Usage as expression\n	os := $if windows { 'Windows' } $else { 'UNIX' }\n	println('Using ${os}')\n	// $else-$if branches\n	$if tinyc {\n		println('tinyc')\n	} $else $if clang {\n		println('clang')\n	} $else $if gcc {\n		println('gcc')\n	} $else {\n		println('different compiler')\n	}\n	$if test {\n		println('testing')\n	}\n	// v -cg ...\n	$if debug {\n		println('debugging')\n	}\n	// v -prod ...\n	$if prod {\n		println('production build')\n	}\n	// v -d option ...\n	$if option ? {\n		println('custom option')\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>If you want an <code>if</code> to be evaluated at compile time it must be prefixed with a <code>$</code> sign.
Right now it can be used to detect an OS, compiler, platform or compilation options.
<code>$if debug</code> is a special option like <code>$if windows</code> or <code>$if x32</code>, it's enabled if the program
is compiled with <code>v -g</code> or <code>v -cg</code>.
If you're using a custom ifdef, then you do need <code>$if option ? {}</code> and compile with<code>v -d option</code>.
Full list of builtin options:</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>Compilers</th>
<th>Platforms</th>
<th>Other</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>windows</code>, <code>linux</code>, <code>macos</code></td>
<td><code>gcc</code>, <code>tinyc</code></td>
<td><code>amd64</code>, <code>arm64</code></td>
<td><code>debug</code>, <code>prod</code>, <code>test</code></td>
</tr>
<tr>
<td><code>mac</code>, <code>darwin</code>, <code>ios</code>,</td>
<td><code>clang</code>, <code>mingw</code></td>
<td><code>x64</code>, <code>x32</code></td>
<td><code>js</code>, <code>glibc</code>, <code>prealloc</code></td>
</tr>
<tr>
<td><code>android</code>, <code>mach</code>, <code>dragonfly</code></td>
<td><code>msvc</code></td>
<td><code>little_endian</code></td>
<td><code>no_bounds_checking</code>, <code>freestanding</code></td>
</tr>
<tr>
<td><code>gnu</code>, <code>hpux</code>, <code>haiku</code>, <code>qnx</code></td>
<td><code>cplusplus</code></td>
<td><code>big_endian</code></td>
<td><code>no_segfault_handler</code>, <code>no_backtrace</code>, <code>no_main</code></td>
</tr>
<tr>
<td><code>solaris</code>, <code>termux</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="embed_file"><a class="markdownIt-Anchor" href="#embed_file">#</a> <code>$embed_file</code></h4>
{% set code = "import os\nfn main() {\n	embedded_file := $embed_file('v.png')\n	os.write_file('exported.png', embedded_file.to_string())!\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V can embed arbitrary files into the executable with the <code>$embed_file(&lt;path&gt;)</code>
compile time call. Paths can be absolute or relative to the source file.</p>
<p>When you do not use <code>-prod</code>, the file will not be embedded. Instead, it will
be loaded <em>the first time</em> your program calls <code>embedded_file.data()</code> at runtime, making
it easier to change in external editor programs, without needing to recompile
your executable.</p>
<p>When you compile with <code>-prod</code>, the file <em>will be embedded inside</em> your
executable, increasing your binary size, but making it more self contained
and thus easier to distribute. In this case, <code>embedded_file.data()</code> will cause <em>no IO</em>,
and it will always return the same data.</p>
<p><code>$embed_file</code> supports compression of the embedded file when compiling with <code>-prod</code>.
Currently only one compression type is supported: <code>zlib</code></p>
{% set code = "import os\nfn main() {\n	embedded_file := $embed_file('v.png', .zlib) // compressed using zlib\n	os.write_file('exported.png', embedded_file.to_string())!\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p><code>$embed_file</code> returns
<a href="https://modules.vlang.io/v.embed_file.html#EmbedFileData">EmbedFileData</a>
which could be used to obtain the file contents as <code>string</code> or <code>[]u8</code>.</p>
<h4 id="tmpl-for-embedding-and-parsing-v-template-files"><a class="markdownIt-Anchor" href="#tmpl-for-embedding-and-parsing-v-template-files">#</a> <code>$tmpl</code> for embedding and parsing V template files</h4>
<p>V has a simple template language for text and html templates, and they can easily
be embedded via <code>$tmpl('path/to/template.txt')</code>:</p>
{% set code = "fn build() string {\n	name := 'Peter'\n	age := 25\n	numbers := [1, 2, 3]\n	return $tmpl('1.txt')\n}\n\nfn main() {\n	println(build())\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>1.txt:</p>
{% set code = "name: @name\n\nage: @age\n\nnumbers: @numbers\n\n@for number in numbers\n  @number\n@end" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>output:</p>
{% set code = "name: Peter\n\nage: 25\n\nnumbers: [1, 2, 3]\n\n1\n2\n3" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>See more <a href="https://github.com/vlang/v/blob/master/vlib/v/TEMPLATES.md">details</a></p>
<h4 id="env"><a class="markdownIt-Anchor" href="#env">#</a> <code>$env</code></h4>
{% set code = "module main\n\nfn main() {\n	compile_time_env := $env('ENV_VAR')\n	println(compile_time_env)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>V can bring in values at compile time from environment variables.
<code>$env('ENV_VAR')</code> can also be used in top-level <code>#flag</code> and <code>#include</code> statements:
<code>#flag linux -I $env('JAVA_HOME')/include</code>.</p>
<h4 id="compile_error-and-compile_warn"><a class="markdownIt-Anchor" href="#compile_error-and-compile_warn">#</a> <code>$compile_error</code> and <code>$compile_warn</code></h4>
<p>These two comptime functions are very useful for displaying custom errors/warnings during
compile time.</p>
<p>Both receive as their only argument a string literal that contains the message to display:</p>
{% set code = "// x.v\nmodule main\n\n$if linux {\n    $compile_error('Linux is not supported')\n}\n\nfn main() {\n}\n\n$ v run x.v\nx.v:4:5: error: Linux is not supported\n    2 |\n    3 | $if linux {\n    4 |     $compile_error('Linux is not supported')\n      |     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    5 | }\n    6 |" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="environment-specific-files"><a class="markdownIt-Anchor" href="#environment-specific-files">#</a> Environment specific files</h3>
<p>If a file has an environment-specific suffix, it will only be compiled for that environment.</p>
<ul>
<li><code>.js.v</code> =&gt; will be used only by the JS backend. These files can contain JS. code.</li>
<li><code>.c.v</code> =&gt; will be used only by the C backend. These files can contain C. code.</li>
<li><code>.native.v</code> =&gt; will be used only by V's native backend.</li>
<li><code>_nix.c.v</code> =&gt; will be used only on Unix systems (non Windows).</li>
<li><code>_${os}.c.v</code> =&gt; will be used only on the specific <code>os</code> system.
For example, <code>_windows.c.v</code> will be used only when compiling on Windows, or with <code>-os windows</code>.</li>
<li><code>_default.c.v</code> =&gt; will be used only if there is NOT a more specific platform file.
For example, if you have both <code>file_linux.c.v</code> and <code>file_default.c.v</code>,
and you are compiling for linux, then only <code>file_linux.c.v</code> will be used,
and <code>file_default.c.v</code> will be ignored.</li>
</ul>
<p>Here is a more complete example:
main.v:</p>
{% set code = "module main\nfn main() { println(message) }" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>main_default.c.v:</p>
{% set code = "module main\nconst ( message = 'Hello world' )" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>main_linux.c.v:</p>
{% set code = "module main\nconst ( message = 'Hello linux' )" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>main_windows.c.v:</p>
{% set code = "module main\nconst ( message = 'Hello windows' )" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>With the example above:</p>
<ul>
<li>
<p>when you compile for windows, you will get 'Hello windows'</p>
</li>
<li>
<p>when you compile for linux, you will get 'Hello linux'</p>
</li>
<li>
<p>when you compile for any other platform, you will get the
non specific 'Hello world' message.</p>
</li>
<li>
<p><code>_d_customflag.v</code> =&gt; will be used <em>only</em> if you pass <code>-d customflag</code> to V.
That corresponds to <code>$if customflag ? {}</code>, but for a whole file, not just a
single block. <code>customflag</code> should be a snake_case identifier, it can not
contain arbitrary characters (only lower case latin letters + numbers + <code>_</code>).</p>
<blockquote>
<p><strong>Note</strong></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>A combinatorial <code>_d_customflag_linux.c.v</code> postfix will not work.
If you do need a custom flag file, that has platform dependent code, use the
postfix <code>_d_customflag.v</code>, and then use platform dependent compile time
conditional blocks inside it, i.e. <code>$if linux {}</code> etc.</p>
</blockquote>
<ul>
<li><code>_notd_customflag.v</code> =&gt; similar to _d_customflag.v, but will be used
<em>only</em> if you do NOT pass <code>-d customflag</code> to V.</li>
</ul>
<p>See also <a href="#cross-compilation">Cross Compilation</a>.</p>
<h2 id="memory-unsafe-code"><a class="markdownIt-Anchor" href="#memory-unsafe-code">#</a> Memory-unsafe code</h2>
<p>Sometimes for efficiency you may want to write low-level code that can potentially
corrupt memory or be vulnerable to security exploits. V supports writing such code,
but not by default.</p>
<p>V requires that any potentially memory-unsafe operations are marked intentionally.
Marking them also indicates to anyone reading the code that there could be
memory-safety violations if there was a mistake.</p>
<p>Examples of potentially memory-unsafe operations are:</p>
<ul>
<li>Pointer arithmetic</li>
<li>Pointer indexing</li>
<li>Conversion to pointer from an incompatible type</li>
<li>Calling certain C functions, e.g. <code>free</code>, <code>strlen</code> and <code>strncmp</code>.</li>
</ul>
<p>To mark potentially memory-unsafe operations, enclose them in an <code>unsafe</code> block:</p>
{% set code = "// allocate 2 uninitialized bytes & return a reference to them\nmut p := unsafe { malloc(2) }\np[0] = `h` // Error: pointer indexing is only allowed in `unsafe` blocks\nunsafe {\n    p[0] = `h` // OK\n    p[1] = `i`\n}\np++ // Error: pointer arithmetic is only allowed in `unsafe` blocks\nunsafe {\n    p++ // OK\n}\nassert *p == `i`" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Best practice is to avoid putting memory-safe expressions inside an <code>unsafe</code> block,
so that the reason for using <code>unsafe</code> is as clear as possible. Generally any code
you think is memory-safe should not be inside an <code>unsafe</code> block, so the compiler
can verify it.</p>
<p>If you suspect your program does violate memory-safety, you have a head start on
finding the cause: look at the <code>unsafe</code> blocks (and how they interact with
surrounding code).</p>
<blockquote>
<p><strong>Note</strong>
This is work in progress.</p>
</blockquote>
<h2 id="structs-with-reference-fields"><a class="markdownIt-Anchor" href="#structs-with-reference-fields">#</a> Structs with reference fields</h2>
<p>Structs with references require explicitly setting the initial value to a
reference value unless the struct already defines its own initial value.</p>
<p>Zero-value references, or nil pointers, will <strong>NOT</strong> be supported in the future,
for now data structures such as Linked Lists or Binary Trees that rely on reference
fields that can use the value <code>0</code>, understanding that it is unsafe, and that it can
cause a panic.</p>
{% set code = "struct Node {\n	a &Node\n	b &Node = unsafe { nil } // Auto-initialized to nil, use with caution!\n}\n\n// Reference fields must be initialized unless an initial value is declared.\n// Zero (0) is OK but use with caution, it's a nil pointer.\nfoo := Node{\n	a: 0\n}\nbar := Node{\n	a: &foo\n}\nbaz := Node{\n	a: 0\n	b: 0\n}\nqux := Node{\n	a: &foo\n	b: &bar\n}\nprintln(baz)\nprintln(qux)" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="sizeof-and-__offsetof"><a class="markdownIt-Anchor" href="#sizeof-and-__offsetof">#</a> sizeof and __offsetof</h2>
<ul>
<li><code>sizeof(Type)</code> gives the size of a type in bytes.</li>
<li><code>__offsetof(Struct, field_name)</code> gives the offset in bytes of a struct field.</li>
</ul>
{% set code = "struct Foo {\n	a int\n	b int\n}\n\nassert sizeof(Foo) == 8\nassert __offsetof(Foo, a) == 0\nassert __offsetof(Foo, b) == 4" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h2 id="limited-operator-overloading"><a class="markdownIt-Anchor" href="#limited-operator-overloading">#</a> Limited operator overloading</h2>
<p>Operator overloading defines the behavior of certain binary operators for certain types.</p>
{% set code = "struct Vec {\n	x int\n	y int\n}\n\nfn (a Vec) str() string {\n	return '{${a.x}, ${a.y}}'\n}\n\nfn (a Vec) + (b Vec) Vec {\n	return Vec{a.x + b.x, a.y + b.y}\n}\n\nfn (a Vec) - (b Vec) Vec {\n	return Vec{a.x - b.x, a.y - b.y}\n}\n\nfn main() {\n	a := Vec{2, 3}\n	b := Vec{4, 5}\n	mut c := Vec{1, 2}\n\n	println(a + b) // \"{6, 8}\"\n	println(a - b) // \"{-2, -2}\"\n	c += a\n	//^^ autogenerated from + overload\n	println(c) // \"{3, 5}\"\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p>Operator overloading goes against V's philosophy of simplicity and predictability.
But since scientific and graphical applications are among V's domains,
operator overloading is an important feature to have in order to improve readability:</p>
<p><code>a.add(b).add(c.mul(d))</code> is a lot less readable than <code>a + b + c * d</code>.</p>
</blockquote>
<p>Operator overloading is possible for the following binary operators: <code>+, -, *, /, %, &lt;, ==</code>.</p>
<h3 id="implicitly-generated-overloads"><a class="markdownIt-Anchor" href="#implicitly-generated-overloads">#</a> Implicitly generated overloads</h3>
<ul>
<li>
<p><code>==</code> is automatically generated by the compiler, but can be overridden.</p>
</li>
<li>
<p><code>!=</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> are automatically generated when <code>==</code> and <code>&lt;</code> are defined.
They cannot be explicitly overridden.</p>
</li>
<li>
<p>Assignment operators (<code>*=</code>, <code>+=</code>, <code>/=</code>, etc) are automatically generated when the corresponding
operators are defined and the operands are of the same type.
They cannot be explicitly overridden.</p>
</li>
</ul>
<h3 id="restriction"><a class="markdownIt-Anchor" href="#restriction">#</a> Restriction</h3>
<p>To improve safety and maintainability, operator overloading is limited.</p>
<h4 id="type-restrictions"><a class="markdownIt-Anchor" href="#type-restrictions">#</a> Type restrictions</h4>
<ul>
<li>When overriding <code>&lt;</code> and <code>==</code>, the return type must be strictly <code>bool</code>.</li>
<li>Both arguments must have the same type (just like with all operators in V).</li>
</ul>
<h4 id="other-restrictions"><a class="markdownIt-Anchor" href="#other-restrictions">#</a> Other restrictions</h4>
<ul>
<li>Arguments cannot be changed inside overloads.</li>
<li>Calling other functions inside operator functions is not allowed (<strong>planned</strong>).</li>
</ul>
<h2 id="performance-tuning"><a class="markdownIt-Anchor" href="#performance-tuning">#</a> Performance tuning</h2>
<p>The generated C code is usually fast enough, when you compile your code
with <code>-prod</code>. There are some situations though, where you may want to give
additional hints to the compiler, so that it can further optimize some
blocks of code.</p>
<blockquote>
<p><strong>Note</strong>
These are <em>rarely</em> needed, and should not be used, unless you
<em>profile your code</em>, and then see that there are significant benefits for them.
To cite gcc's documentation: &quot;programmers are notoriously bad at predicting
how their programs actually perform&quot;.</p>
</blockquote>
<p><code>[inline]</code> - you can tag functions with <code>[inline]</code>, so the C compiler will
try to inline them, which in some cases, may be beneficial for performance,
but may impact the size of your executable.</p>
<p><code>[direct_array_access]</code> - in functions tagged with <code>[direct_array_access]</code>
the compiler will translate array operations directly into C array operations -
omitting bounds checking. This may save a lot of time in a function that iterates
over an array but at the cost of making the function unsafe - unless
the boundaries will be checked by the user.</p>
<p><code>if _likely_(bool expression) {</code> this hints the C compiler, that the passed
boolean expression is very likely to be true, so it can generate assembly
code, with less chance of branch misprediction. In the JS backend,
that does nothing.</p>
<p><code>if _unlikely_(bool expression) {</code> similar to <code>_likely_(x)</code>, but it hints that
the boolean expression is highly improbable. In the JS backend, that does nothing.</p>
<p>&lt;a id='Reflection via codegen'&gt;</p>
<h2 id="atomics"><a class="markdownIt-Anchor" href="#atomics">#</a> Atomics</h2>
<p>V has no special support for atomics, yet, nevertheless it's possible to treat variables as atomics
by <a href="#v-and-c">calling C</a> functions from V. The standard C11 atomic functions like <code>atomic_store()</code>
are usually defined with the help of macros and C compiler magic to provide a kind of
<em>overloaded C functions</em>.
Since V does not support overloading functions by intention there are wrapper functions defined in
C headers named <code>atomic.h</code> that are part of the V compiler infrastructure.</p>
<p>There are dedicated wrappers for all unsigned integer types and for pointers.
(<code>byte</code> is not fully supported on Windows) ‚Äì the function names include the type name
as suffix. e.g. <code>C.atomic_load_ptr()</code> or <code>C.atomic_fetch_add_u64()</code>.</p>
<p>To use these functions the C header for the used OS has to be included and the functions
that are intended to be used have to be declared. Example:</p>
{% set code = "$if windows {\n	#include \"@VEXEROOT/thirdparty/stdatomic/win/atomic.h\"\n} $else {\n	#include \"@VEXEROOT/thirdparty/stdatomic/nix/atomic.h\"\n}\n\n// declare functions we want to use - V does not parse the C header\nfn C.atomic_store_u32(&u32, u32)\nfn C.atomic_load_u32(&u32) u32\nfn C.atomic_compare_exchange_weak_u32(&u32, &u32, u32) bool\nfn C.atomic_compare_exchange_strong_u32(&u32, &u32, u32) bool\n\nconst num_iterations = 10000000\n\n// see section \"Global Variables\" below\n__global (\n	atom u32 // ordinary variable but used as atomic\n)\n\nfn change() int {\n	mut races_won_by_change := 0\n	for {\n		mut cmp := u32(17) // addressable value to compare with and to store the found value\n		// atomic version of `if atom == 17 { atom = 23 races_won_by_change++ } else { cmp = atom }`\n		if C.atomic_compare_exchange_strong_u32(&atom, &cmp, 23) {\n			races_won_by_change++\n		} else {\n			if cmp == 31 {\n				break\n			}\n			cmp = 17 // re-assign because overwritten with value of atom\n		}\n	}\n	return races_won_by_change\n}\n\nfn main() {\n	C.atomic_store_u32(&atom, 17)\n	t := spawn change()\n	mut races_won_by_main := 0\n	mut cmp17 := u32(17)\n	mut cmp23 := u32(23)\n	for i in 0 .. num_iterations {\n		// atomic version of `if atom == 17 { atom = 23 races_won_by_main++ }`\n		if C.atomic_compare_exchange_strong_u32(&atom, &cmp17, 23) {\n			races_won_by_main++\n		} else {\n			cmp17 = 17\n		}\n		desir := if i == num_iterations - 1 { u32(31) } else { u32(17) }\n		// atomic version of `for atom != 23 {} atom = desir`\n		for !C.atomic_compare_exchange_weak_u32(&atom, &cmp23, desir) {\n			cmp23 = 23\n		}\n	}\n	races_won_by_change := t.wait()\n	atom_new := C.atomic_load_u32(&atom)\n	println('atom: ${atom_new}, #exchanges: ${races_won_by_main + races_won_by_change}')\n	// prints `atom: 31, #exchanges: 10000000`)\n	println('races won by\n- `main()`: ${races_won_by_main}\n- `change()`: ${races_won_by_change}')\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>In this example both <code>main()</code> and the spawned thread <code>change()</code> try to replace a value of <code>17</code>
in the global <code>atom</code> with a value of <code>23</code>. The replacement in the opposite direction is
done exactly 10000000 times. The last replacement will be with <code>31</code> which makes the spawned
thread finish.</p>
<p>It is not predictable how many replacements occur in which thread, but the sum will always
be 10000000. (With the non-atomic commands from the comments the value will be higher or the program
will hang ‚Äì dependent on the compiler optimization used.)</p>
<h2 id="global-variables"><a class="markdownIt-Anchor" href="#global-variables">#</a> Global Variables</h2>
<p>By default V does not allow global variables. However, in low level applications they have their
place so their usage can be enabled with the compiler flag <code>-enable-globals</code>.
Declarations of global variables must be surrounded with a <code>__global ( ... )</code>
specification ‚Äì as in the example <a href="#atomics">above</a>.</p>
<p>An initializer for global variables must be explicitly converted to the
desired target type. If no initializer is given a default initialization is done.
Some objects like semaphores and mutexes require an explicit initialization <em>in place</em>, i.e.
not with a value returned from a function call but with a method call by reference.
A separate <code>init()</code> function can be used for this purpose ‚Äì it will be called before <code>main()</code>:</p>
{% set code = "import sync\n\n__global (\n	sem   sync.Semaphore // needs initialization in `init()`\n	mtx   sync.RwMutex // needs initialization in `init()`\n	f1    = f64(34.0625) // explicily initialized\n	shmap shared map[string]f64 // initialized as empty `shared` map\n	f2    f64 // initialized to `0.0`\n)\n\nfn init() {\n	sem.init(0)\n	mtx.init()\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Be aware that in multi threaded applications the access to global variables is subject
to race conditions. There are several approaches to deal with these:</p>
<ul>
<li>use <code>shared</code> types for the variable declarations and use <code>lock</code> blocks for access.
This is most appropriate for larger objects like structs, arrays or maps.</li>
<li>handle primitive data types as &quot;atomics&quot; using special C-functions (see <a href="#atomics">above</a>).</li>
<li>use explicit synchronization primitives like mutexes to control access. The compiler
cannot really help in this case, so you have to know what you are doing.</li>
<li>don't care ‚Äì this approach is possible but makes only sense if the exact values
of global variables do not really matter. An example can be found in the <code>rand</code> module
where global variables are used to generate (non cryptographic) pseudo random numbers.
In this case data races lead to random numbers in different threads becoming somewhat
correlated, which is acceptable considering the performance penalty that using
synchronization primitives would represent.</li>
</ul>
<h2 id="cross-compilation"><a class="markdownIt-Anchor" href="#cross-compilation">#</a> Cross compilation</h2>
<p>To cross compile your project simply run</p>
{% set code = "v -os windows ." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>or</p>
{% set code = "v -os linux ." %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
Cross-compiling a windows binary on a linux machine requires the GNU C compiler for
MinGW-w64 (targeting Win64) to first be installed.</p>
</blockquote>
<p>For Ubuntu/Debian based distributions:</p>
{% set code = "sudo apt-get install gcc-mingw-w64-x86-64" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>For Arch based distributions:</p>
{% set code = "sudo pacman -S mingw-w64-gcc" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>(Cross compiling for macOS is temporarily not possible.)</p>
<p>If you don't have any C dependencies, that's all you need to do. This works even
when compiling GUI apps using the <code>ui</code> module or graphical apps using <code>gg</code>.</p>
<p>You will need to install Clang, LLD linker, and download a zip file with
libraries and include files for Windows and Linux. V will provide you with a link.</p>
<h2 id="debugging"><a class="markdownIt-Anchor" href="#debugging">#</a> Debugging</h2>
<h3 id="c-backend-binaries-default"><a class="markdownIt-Anchor" href="#c-backend-binaries-default">#</a> C Backend binaries (Default)</h3>
<p>To debug issues in the generated binary (flag: <code>-b c</code>), you can pass these flags:</p>
<ul>
<li><code>-g</code> - produces a less optimized executable with more debug information in it.
V will enforce line numbers from the .v files in the stacktraces, that the
executable will produce on panic. It is usually better to pass -g, unless
you are writing low level code, in which case use the next option <code>-cg</code>.</li>
<li><code>-cg</code> - produces a less optimized executable with more debug information in it.
The executable will use C source line numbers in this case. It is frequently
used in combination with <code>-keepc</code>, so that you can inspect the generated
C program in case of panic, or so that your debugger (<code>gdb</code>, <code>lldb</code> etc.)
can show you the generated C source code.</li>
<li><code>-showcc</code> - prints the C command that is used to build the program.</li>
<li><code>-show-c-output</code> - prints the output, that your C compiler produced
while compiling your program.</li>
<li><code>-keepc</code> - do not delete the generated C source code file after a successful
compilation. Also keep using the same file path, so it is more stable,
and easier to keep opened in an editor/IDE.</li>
</ul>
<p>For best debugging experience if you are writing a low level wrapper for an existing
C library, you can pass several of these flags at the same time:
<code>v -keepc -cg -showcc yourprogram.v</code>, then just run your debugger (gdb/lldb) or IDE
on the produced executable <code>yourprogram</code>.</p>
<p>If you just want to inspect the generated C code,
without further compilation, you can also use the <code>-o</code> flag (e.g. <code>-o file.c</code>).
This will make V produce the <code>file.c</code> then stop.</p>
<p>If you want to see the generated C source code for <em>just</em> a single C function,
for example <code>main</code>, you can use: <code>-printfn main -o file.c</code>.</p>
<p>To debug the V executable itself you need to compile from src with <code>./v -g -o v cmd/v</code>.</p>
<p>You can debug tests with for example <code>v -g -keepc prog_test.v</code>. The <code>-keepc</code> flag is needed,
so that the executable is not deleted, after it was created and ran.</p>
<p>To see a detailed list of all flags that V supports,
use <code>v help</code>, <code>v help build</code> and <code>v help build-c</code>.</p>
<p><strong>Commandline Debugging</strong></p>
<ol>
<li>compile your binary with debugging info <code>v -g hello.v</code></li>
<li>debug with <a href="https://lldb.llvm.org">lldb</a> or <a href="https://www.gnu.org/software/gdb/">GDB</a>
e.g. <code>lldb hello</code></li>
</ol>
<p><a href="https://github.com/vlang/v/wiki/Troubleshooting-(debugging)-executables-created-with-V-in-GDB">Troubleshooting (debugging) executables created with V in GDB</a></p>
<p><strong>Visual debugging Setup:</strong></p>
<ul>
<li><a href="vscode.md">Visual Studio Code</a></li>
</ul>
<h3 id="native-backend-binaries"><a class="markdownIt-Anchor" href="#native-backend-binaries">#</a> Native Backend binaries</h3>
<p>Currently there is no debugging support for binaries, created by the
native backend (flag: <code>-b native</code>).</p>
<h3 id="javascript-backend"><a class="markdownIt-Anchor" href="#javascript-backend">#</a> Javascript Backend</h3>
<p>To debug the generated Javascript output you can activate source maps:
<code>v -b js -sourcemap hello.v -o hello.js</code></p>
<p>For all supported options check the latest help:
<code>v help build-js</code></p>
<h2 id="v-and-c"><a class="markdownIt-Anchor" href="#v-and-c">#</a> V and C</h2>
<h3 id="calling-c-from-v"><a class="markdownIt-Anchor" href="#calling-c-from-v">#</a> Calling C from V</h3>
<p><strong>Example</strong></p>
{% set code = "#flag -lsqlite3\n#include \"sqlite3.h\"\n// See also the example from https://www.sqlite.org/quickstart.html\nstruct C.sqlite3 {\n}\n\nstruct C.sqlite3_stmt {\n}\n\ntype FnSqlite3Callback = fn (voidptr, int, &&char, &&char) int\n\nfn C.sqlite3_open(&char, &&C.sqlite3) int\n\nfn C.sqlite3_close(&C.sqlite3) int\n\nfn C.sqlite3_column_int(stmt &C.sqlite3_stmt, n int) int\n\n// ... you can also just define the type of parameter and leave out the C. prefix\n\nfn C.sqlite3_prepare_v2(&C.sqlite3, &char, int, &&C.sqlite3_stmt, &&char) int\n\nfn C.sqlite3_step(&C.sqlite3_stmt)\n\nfn C.sqlite3_finalize(&C.sqlite3_stmt)\n\nfn C.sqlite3_exec(db &C.sqlite3, sql &char, cb FnSqlite3Callback, cb_arg voidptr, emsg &&char) int\n\nfn C.sqlite3_free(voidptr)\n\nfn my_callback(arg voidptr, howmany int, cvalues &&char, cnames &&char) int {\n	unsafe {\n		for i in 0 .. howmany {\n			print('| ${cstring_to_vstring(cnames[i])}: ${cstring_to_vstring(cvalues[i]):20} ')\n		}\n	}\n	println('|')\n	return 0\n}\n\nfn main() {\n	db := &C.sqlite3(0) // this means `sqlite3* db = 0`\n	// passing a string literal to a C function call results in a C string, not a V string\n	C.sqlite3_open(c'users.db', &db)\n	// C.sqlite3_open(db_path.str, &db)\n	query := 'select count(*) from users'\n	stmt := &C.sqlite3_stmt(0)\n	// Note: You can also use the `.str` field of a V string,\n	// to get its C style zero terminated representation\n	C.sqlite3_prepare_v2(db, &char(query.str), -1, &stmt, 0)\n	C.sqlite3_step(stmt)\n	nr_users := C.sqlite3_column_int(stmt, 0)\n	C.sqlite3_finalize(stmt)\n	println('There are ${nr_users} users in the database.')\n	//\n	error_msg := &char(0)\n	query_all_users := 'select * from users'\n	rc := C.sqlite3_exec(db, &char(query_all_users.str), my_callback, voidptr(7), &error_msg)\n	if rc != C.SQLITE_OK {\n		eprintln(unsafe { cstring_to_vstring(error_msg) })\n		C.sqlite3_free(error_msg)\n	}\n	C.sqlite3_close(db)\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="calling-v-from-c"><a class="markdownIt-Anchor" href="#calling-v-from-c">#</a> Calling V from C</h3>
<p>Since V can compile to C, calling V code from C is very easy, once you know how.</p>
<p>Use <code>v -o file.c your_file.v</code> to generate a C file, corresponding to the V code.</p>
<p>More details in <a href="../examples/call_v_from_c">call_v_from_c example</a>.</p>
<h3 id="passing-c-compilation-flags"><a class="markdownIt-Anchor" href="#passing-c-compilation-flags">#</a> Passing C compilation flags</h3>
<p>Add <code>#flag</code> directives to the top of your V files to provide C compilation flags like:</p>
<ul>
<li><code>-I</code> for adding C include files search paths</li>
<li><code>-l</code> for adding C library names that you want to get linked</li>
<li><code>-L</code> for adding C library files search paths</li>
<li><code>-D</code> for setting compile time variables</li>
</ul>
<p>You can (optionally) use different flags for different targets.
Currently the <code>linux</code>, <code>darwin</code> , <code>freebsd</code>, and <code>windows</code> flags are supported.</p>
<blockquote>
<p><strong>Note</strong>
Each flag must go on its own line (for now)</p>
</blockquote>
{% set code = "#flag linux -lsdl2\n#flag linux -Ivig\n#flag linux -DCIMGUI_DEFINE_ENUMS_AND_STRUCTS=1\n#flag linux -DIMGUI_DISABLE_OBSOLETE_FUNCTIONS=1\n#flag linux -DIMGUI_IMPL_API=" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>In the console build command, you can use:</p>
<ul>
<li><code>-cflags</code> to pass custom flags to the backend C compiler.</li>
<li><code>-cc</code> to change the default C backend compiler.</li>
<li>For example: <code>-cc gcc-9 -cflags -fsanitize=thread</code>.</li>
</ul>
<p>You can define a <code>VFLAGS</code> environment variable in your terminal to store your <code>-cc</code>
and <code>-cflags</code> settings, rather than including them in the build command each time.</p>
<h3 id="pkgconfig"><a class="markdownIt-Anchor" href="#pkgconfig">#</a> #pkgconfig</h3>
<p>Add <code>#pkgconfig</code> directive is used to tell the compiler which modules should be used for compiling
and linking using the pkg-config files provided by the respective dependencies.</p>
<p>As long as backticks can't be used in <code>#flag</code> and spawning processes is not desirable for security
and portability reasons, V uses its own pkgconfig library that is compatible with the standard
freedesktop one.</p>
<p>If no flags are passed it will add <code>--cflags</code> and <code>--libs</code>, both lines below do the same:</p>
{% set code = "#pkgconfig r_core\n#pkgconfig --cflags --libs r_core" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The <code>.pc</code> files are looked up into a hardcoded list of default pkg-config paths, the user can add
extra paths by using the <code>PKG_CONFIG_PATH</code> environment variable. Multiple modules can be passed.</p>
<p>To check the existence of a pkg-config use <code>$pkgconfig('pkg')</code> as a compile time &quot;if&quot; condition to
check if a pkg-config exists. If it exists the branch will be created. Use <code>$else</code> or <code>$else $if</code>
to handle other cases.</p>
{% set code = "$if $pkgconfig('mysqlclient') {\n	#pkgconfig mysqlclient\n} $else $if $pkgconfig('mariadb') {\n	#pkgconfig mariadb\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="including-c-code"><a class="markdownIt-Anchor" href="#including-c-code">#</a> Including C code</h3>
<p>You can also include C code directly in your V module.
For example, let's say that your C code is located in a folder named 'c' inside your module folder.
Then:</p>
<ul>
<li>Put a v.mod file inside the toplevel folder of your module (if you
created your module with <code>v new</code> you already have v.mod file). For example:</li>
</ul>
{% set code = "Module {\n	name: 'mymodule',\n	description: 'My nice module wraps a simple C library.',\n	version: '0.0.1'\n	dependencies: []\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<ul>
<li>Add these lines to the top of your module:</li>
</ul>
{% set code = "#flag -I @VMODROOT/c\n#flag @VMODROOT/c/implementation.o\n#include \"header.h\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<blockquote>
<p><strong>Note</strong>
@VMODROOT will be replaced by V with the <em>nearest parent folder,
where there is a v.mod file</em>.
Any .v file beside or below the folder where the v.mod file is,
can use <code>#flag @VMODROOT/abc</code> to refer to this folder.
The @VMODROOT folder is also <em>prepended</em> to the module lookup path,
so you can <em>import</em> other modules under your @VMODROOT, by just naming them.</p>
</blockquote>
<p>The instructions above will make V look for an compiled .o file in
your module <code>folder/c/implementation.o</code>.
If V finds it, the .o file will get linked to the main executable, that used the module.
If it does not find it, V assumes that there is a <code>@VMODROOT/c/implementation.c</code> file,
and tries to compile it to a .o file, then will use that.</p>
<p>This allows you to have C code, that is contained in a V module, so that its distribution is easier.
You can see a complete minimal example for using C code in a V wrapper module here:
<a href="https://github.com/vlang/v/tree/master/vlib/v/tests/project_with_c_code">project_with_c_code</a>.
Another example, demonstrating passing structs from C to V and back again:
<a href="https://github.com/vlang/v/tree/master/vlib/v/tests/project_with_c_code_2">interoperate between C to V to C</a>.</p>
<h3 id="c-types"><a class="markdownIt-Anchor" href="#c-types">#</a> C types</h3>
<p>Ordinary zero terminated C strings can be converted to V strings with
<code>unsafe { &amp;char(cstring).vstring() }</code> or if you know their length already with
<code>unsafe { &amp;char(cstring).vstring_with_len(len) }</code>.</p>
<blockquote>
<p><strong>Note</strong>
The <code>.vstring()</code> and <code>.vstring_with_len()</code> methods do NOT create a copy of the <code>cstring</code>,
so you should NOT free it after calling the method <code>.vstring()</code>.
If you need to make a copy of the C string (some libc APIs like <code>getenv</code> pretty much require that,
since they return pointers to internal libc memory), you can use <code>cstring_to_vstring(cstring)</code>.</p>
</blockquote>
<p>On Windows, C APIs often return so called <code>wide</code> strings (utf16 encoding).
These can be converted to V strings with <code>string_from_wide(&amp;u16(cwidestring))</code> .</p>
<p>V has these types for easier interoperability with C:</p>
<ul>
<li><code>voidptr</code> for C's <code>void*</code>,</li>
<li><code>&amp;byte</code> for C's <code>byte*</code> and</li>
<li><code>&amp;char</code> for C's <code>char*</code>.</li>
<li><code>&amp;&amp;char</code> for C's <code>char**</code></li>
</ul>
<p>To cast a <code>voidptr</code> to a V reference, use <code>user := &amp;User(user_void_ptr)</code>.</p>
<p><code>voidptr</code> can also be dereferenced into a V struct through casting: <code>user := User(user_void_ptr)</code>.</p>
<p><a href="https://github.com/vlang/v/blob/master/vlib/v/tests/project_with_c_code/mod1/wrapper.v">an example of a module that calls C code from V</a></p>
<h3 id="c-declarations"><a class="markdownIt-Anchor" href="#c-declarations">#</a> C Declarations</h3>
<p>C identifiers are accessed with the <code>C</code> prefix similarly to how module-specific
identifiers are accessed. Functions must be redeclared in V before they can be used.
Any C types may be used behind the <code>C</code> prefix, but types must be redeclared in V in
order to access type members.</p>
<p>To redeclare complex types, such as in the following C code:</p>
{% set code = "struct SomeCStruct {\n	uint8_t implTraits;\n	uint16_t memPoolData;\n	union {\n		struct {\n			void* data;\n			size_t size;\n		};\n\n		DataView view;\n	};\n};" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>members of sub-data-structures may be directly declared in the containing struct as below:</p>
{% set code = "struct C.SomeCStruct {\n	implTraits  byte\n	memPoolData u16\n	// These members are part of sub data structures that can't currently be represented in V.\n	// Declaring them directly like this is sufficient for access.\n	// union {\n	// struct {\n	data voidptr\n	size usize\n	// }\n	view C.DataView\n	// }\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>The existence of the data members is made known to V, and they may be used without
re-creating the original structure exactly.</p>
<p>Alternatively, you may <a href="#embedded-structs">embed</a> the sub-data-structures to maintain
a parallel code structure.</p>
<h3 id="export-to-shared-library"><a class="markdownIt-Anchor" href="#export-to-shared-library">#</a> Export to shared library</h3>
<p>By default all V functions have the following naming scheme in C: <code>[module name]__[fn_name]</code>.</p>
<p>For example, <code>fn foo() {}</code> in module <code>bar</code> will result in <code>bar__foo()</code>.</p>
<p>To use a custom export name, use the <code>[export]</code> attribute:</p>
{% set code = "[export: 'my_custom_c_name']\nfn foo() {\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<h3 id="translating-c-to-v"><a class="markdownIt-Anchor" href="#translating-c-to-v">#</a> Translating C to V</h3>
<p>V can translate your C code to human readable V code, and generating V wrappers
on top of C libraries.</p>
<p>C2V currently uses Clang's AST to generate V, so to translate a C file to V
you need to have Clang installed on your machine.</p>
<p>Let's create a simple program <code>test.c</code> first:</p>
{% set code = "#include \"stdio.h\"\n\nint main() {\n	for (int i = 0; i < 10; i++) {\n		printf(\"hello world\n\");\n	}\n        return 0;\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Run <code>v translate test.c</code>, and V will generate <code>test.v</code>:</p>
{% set code = "fn main() {\n	for i := 0; i < 10; i++ {\n		println('hello world')\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>To generate a wrapper on top of a C library use this command:</p>
{% set code = "v translate wrapper c_code/libsodium/src/libsodium" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>This will generate a directory <code>libsodium</code> with a V module.</p>
<p>Example of a C2V generated libsodium wrapper:</p>
<p>https://github.com/vlang/libsodium</p>
<p>&lt;br&gt;</p>
<p>When should you translate C code and when should you simply call C code from V?</p>
<p>If you have well-written, well-tested C code,
then of course you can always simply call this C code from V.</p>
<p>Translating it to V gives you several advantages:</p>
<ul>
<li>If you plan to develop that code base, you now have everything in one language,
which is much safer and easier to develop in than C.</li>
<li>Cross-compilation becomes a lot easier. You don't have to worry about it at all.</li>
<li>No more build flags and include files either.</li>
</ul>
<h3 id="working-around-c-issues"><a class="markdownIt-Anchor" href="#working-around-c-issues">#</a> Working around C issues</h3>
<p>In some cases, C interop can be extremely difficult.
One of these such cases is when headers conflict with each other.
For example, V needs to include the Windows header libraries in order for your V binaries to work
seamlessly across all platforms.</p>
<p>However, since the Windows header libraries use extremely generic names such as <code>Rectangle</code>,
this will cause a conflict if you wish to use C code that also has a name defined as <code>Rectangle</code>.</p>
<p>For very specific cases like this, we have <code>#preinclude</code>.</p>
<p>This will allow things to be configured before V adds in its built in libraries.</p>
<p>Example usage:</p>
{% set code = "// This will include before built in libraries are used.\n#preinclude \"pre_include.h\"\n// This will include after built in libraries are used.\n#include \"include.h\"" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>An example of what might be included in <code>pre_include.h</code>
can be <a href="https://github.com/irishgreencitrus/raylib.v/blob/main/include/pre.h">found here</a></p>
<p>This is an advanced feature, and will not be necessary
outside of very specific cases with C interop,
meaning it could cause more issues than it solves.</p>
<p>Consider it last resort!</p>
<h2 id="other-v-features"><a class="markdownIt-Anchor" href="#other-v-features">#</a> Other V Features</h2>
<h3 id="inline-assembly"><a class="markdownIt-Anchor" href="#inline-assembly">#</a> Inline assembly</h3>
<p>&lt;!-- ignore because it doesn't pass fmt test (why?) --&gt;</p>
{% set code = "a := 100\nb := 20\nmut c := 0\nasm amd64 {\n    mov eax, a\n    add eax, b\n    mov c, eax\n    ; =r (c) as c // output\n    ; r (a) as a // input\n      r (b) as b\n}\nprintln('a: ${a}') // 100\nprintln('b: ${b}') // 20\nprintln('c: ${c}') // 120" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>For more examples, see
<a href="https://github.com/vlang/v/tree/master/vlib/v/tests/assembly/asm_test.amd64.v">github.com/vlang/v/tree/master/vlib/v/tests/assembly/asm_test.amd64.v</a></p>
<h3 id="hot-code-reloading"><a class="markdownIt-Anchor" href="#hot-code-reloading">#</a> Hot code reloading</h3>
{% set code = "module main\n\nimport time\n\n[live]\nfn print_message() {\n	println('Hello! Modify this message while the program is running.')\n}\n\nfn main() {\n	for {\n		print_message()\n		time.sleep(500 * time.millisecond)\n	}\n}" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Build this example with <code>v -live message.v</code>.</p>
<p>You can also run this example with <code>v -live run message.v</code>.
Make sure that in command you use a path to a V's file,
<strong>not</strong> a path to a folder (like <code>v -live run .</code>) -
in that case you need to modify content of a folder (add new file, for example),
because changes in <em>message.v</em> will have no effect.</p>
<p>Functions that you want to be reloaded must have <code>[live]</code> attribute
before their definition.</p>
<p>Right now it's not possible to modify types while the program is running.</p>
<p>More examples, including a graphical application:
<a href="https://github.com/vlang/v/tree/master/examples/hot_reload">github.com/vlang/v/tree/master/examples/hot_reload</a>.</p>
<h3 id="cross-platform-shell-scripts-in-v"><a class="markdownIt-Anchor" href="#cross-platform-shell-scripts-in-v">#</a> Cross-platform shell scripts in V</h3>
<p>V can be used as an alternative to Bash to write deployment scripts, build scripts, etc.</p>
<p>The advantage of using V for this, is the simplicity and predictability of the language, and
cross-platform support. &quot;V scripts&quot; run on Unix-like systems, as well as on Windows.</p>
<p>To use V's script mode, save your source file with the <code>.vsh</code> file extension.
It will make all functions in the <code>os</code> module global (so that you can use <code>mkdir()</code> instead
of <code>os.mkdir()</code>, for example).</p>
<p>V also knows to compile &amp; run <code>.vsh</code> files immediately, so you do not need a separate
step to compile them. V will also recompile an executable, produced by a <code>.vsh</code> file,
<em>only when it is older than the .vsh source file</em>, i.e. runs after the first one, will
be faster, since there is no need for a re-compilation of a script, that has not been changed.</p>
<p>An example <code>deploy.vsh</code>:</p>
{% set code = "#!/usr/bin/env -S v\n\n// Note: The shebang line above, associates the .vsh file to V on Unix-like systems,\n// so it can be run just by specifying the path to the .vsh file, once it's made\n// executable, using `chmod +x deploy.vsh`, i.e. after that chmod command, you can\n// run the .vsh script, by just typing its name/path like this: `./deploy.vsh`\n\n// print command then execute it\nfn sh(cmd string) {\n	println('‚ùØ ${cmd}')\n	print(execute_or_exit(cmd).output)\n}\n\n// Remove if build/ exits, ignore any errors if it doesn't\nrmdir_all('build') or {}\n\n// Create build/, never fails as build/ does not exist\nmkdir('build')?\n\n// Move *.v files to build/\nresult := execute('mv *.v build/')\nif result.exit_code != 0 {\n	println(result.output)\n}\n\nsh('ls')\n\n// Similar to:\n// files := ls('.')?\n// mut count := 0\n// if files.len > 0 {\n//     for file in files {\n//         if file.ends_with('.v') {\n//              mv(file, 'build/') or {\n//                  println('err: ${err}')\n//                  return\n//              }\n//         }\n//         count++\n//     }\n// }\n// if count == 0 {\n//     println('No files')\n// }" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>Now you can either compile this like a normal V program and get an executable you can deploy and run
anywhere:
<code>v deploy.vsh &amp;&amp; ./deploy</code></p>
<p>Or just run it more like a traditional Bash script:
<code>v run deploy.vsh</code></p>
<p>On Unix-like platforms, the file can be run directly after making it executable using <code>chmod +x</code>:
<code>./deploy.vsh</code></p>
<h3 id="vsh-scripts-with-no-extension"><a class="markdownIt-Anchor" href="#vsh-scripts-with-no-extension">#</a> Vsh scripts with no extension</h3>
<p>Whilst V does normally not allow vsh scripts without the designated file extension, there is a way
to circumvent this rule and have a file with a fully custom name and shebang. Whilst this feature
exists it is only recommended for specific usecases like scripts that will be put in the path and
should <strong>not</strong> be used for things like build or deploy scripts. To access this feature start the
file with <code>#!/usr/bin/env -S v -raw-vsh-tmp-prefix tmp</code> where <code>tmp</code> is the prefix for
the built executable. This will run in crun mode so it will only rebuild if changes to the script
were made and keep the binary as <code>tmp.&lt;scriptfilename&gt;</code>. <strong>Caution</strong>: if this filename already
exists the file will be overridden. If you want to rebuild each time and not keep this binary
instead use <code>#!/usr/bin/env -S v -raw-vsh-tmp-prefix tmp run</code>.</p>
<h1 id="appendices"><a class="markdownIt-Anchor" href="#appendices">#</a> Appendices</h1>
<h2 id="appendix-i-keywords"><a class="markdownIt-Anchor" href="#appendix-i-keywords">#</a> Appendix I: Keywords</h2>
<p>V has 44 reserved keywords (3 are literals):</p>
{% set code = "as\nasm\nassert\natomic\nbreak\nconst\ncontinue\ndefer\nelse\nenum\nfalse\nfn\nfor\ngo\ngoto\nif\nimport\nin\ninterface\nis\nisreftype\nlock\nmatch\nmodule\nmut\nnone\nor\npub\nreturn\nrlock\nselect\nshared\nsizeof\nspawn\nstatic\nstruct\ntrue\ntype\ntypeof\nunion\nunsafe\nvolatile\n__global\n__offsetof" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
<p>See also <a href="#v-types">V Types</a>.</p>
<h2 id="appendix-ii-operators"><a class="markdownIt-Anchor" href="#appendix-ii-operators">#</a> Appendix II: Operators</h2>
<p>This lists operators for <a href="#primitive-types">primitive types</a> only.</p>
{% set code = "+    sum                    integers, floats, strings\n-    difference             integers, floats\n*    product                integers, floats\n/    quotient               integers, floats\n%    remainder              integers\n\n~    bitwise NOT            integers\n&    bitwise AND            integers\n|    bitwise OR             integers\n^    bitwise XOR            integers\n\n!    logical NOT            bools\n&&   logical AND            bools\n||   logical OR             bools\n!=   logical XOR            bools\n\n<<   left shift             integer << unsigned integer\n>>   right shift            integer >> unsigned integer\n>>>  unsigned right shift   integer >> unsigned integer\n\n\nPrecedence    Operator\n    5            *  /  %  <<  >> >>> &\n    4            +  -  |  ^\n    3            ==  !=  <  <=  >  >=\n    2            &&\n    1            ||\n\n\nAssignment Operators\n+=   -=   *=   /=   %=\n&=   |=   ^=\n>>=  <<=  >>>=" %}
    {% set noheader = true  %}
    {% include '../components/codeblock.njk' %}
    {% set noheader = false %}
